Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Address methodsFor: 'initialization' stamp: 'JulianBayardo 11/23/2017 13:55'!initializeStreet: aStreetName number: aStreetNumber town: aTownName province: aProvinceName zipCode: aZipCode	aStreetNumber > 0		ifFalse: [ ImportError new signal: Import addressStreetNumberMustBePositive ].	aZipCode > 0		ifFalse: [ ImportError new signal: Import zipCodeMustBePositive ].	streetName := aStreetName.	streetNumber := aStreetNumber.	town := aTownName.	province := aProvinceName.	zipCode := aZipCode! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'comparing' stamp: 'JulianBayardo 11/7/2017 00:00'!= anAddress	^ self streetName = anAddress streetName and: (self streetNumber = anAddress streetNumber and: (self town = anAddress town and: (self zipCode = anAddress zipCode and: (self province = anAddress province)))).! !!Address methodsFor: 'comparing' stamp: 'JulianBayardo 11/7/2017 00:08'!hash	^ self streetName hash		bitXor:			(self streetNumber hash bitXor: (self town hash bitXor: (self zipCode hash bitXor: self province hash)))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Address class	instanceVariableNames: ''!!Address class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 19:34'!street: aStreetName number: aStreetNumber town: aTownName zipCode: aZipCode province: aProvinceName	^ self new initializeStreet: aStreetName number: aStreetNumber town: aTownName province: aProvinceName zipCode: aZipCode! !Object subclass: #Enviroment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Enviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:07'!createErpSystem	self subclassResponsibility .! !!Enviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/13/2017 22:28'!isActive	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Enviroment class	instanceVariableNames: ''!!Enviroment class methodsFor: 'accessing' stamp: 'JulianBayardo 11/23/2017 16:41'!current	^ (self subclasses collect: [ :aClass | aClass new ])		detect: [ :anEnvironment | anEnvironment isActive ]		ifFound: [ :anEnvironment | ^ anEnvironment ]		ifNone: [ ^ Exception new signal: 'Could not detect what the active running environment is' ]! !TestCase subclass: #ErpTest	instanceVariableNames: 'system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ErpTest methodsFor: 'testing' stamp: 'JulianBayardo 11/23/2017 14:28'!customerImportedWithAddresses: anExpectedCustomer	| customer |	customer := system fetchSingleCustomerByIdentification: anExpectedCustomer identification ifNone: [ self fail ].	self assert: customer equals: anExpectedCustomer.	^ customer! !!ErpTest methodsFor: 'testing' stamp: 'JulianBayardo 11/23/2017 17:58'!should: aBlock raise: anExceptionClass description: anExpectedDescription	" Esto está hecho así porque nos equivocamos al comienzo y utilizamos este mensaje, cuando el que realmente necesitabamos era el de abajo. "	^ self should: aBlock raise: anExceptionClass withExceptionDo: [ :anException | self assert: anException messageText equals: anExpectedDescription ]! !!ErpTest methodsFor: 'testing' stamp: 'JulianBayardo 11/23/2017 14:28'!customerImported: anExpectedCustomer	| customer |	customer := system fetchSingleCustomerByIdentification: anExpectedCustomer identification ifNone: [ self fail ].	self assert: customer firstName equals: anExpectedCustomer firstName.	self assert: customer lastName equals: anExpectedCustomer lastName.	^ customer! !!ErpTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 14:21'!instanceHomelessPepeSanchez	^ Customer		first: 'Pepe'		last: 'Sanchez'		identification: (Identification number: '22333444' type: 'D')! !!ErpTest methodsFor: 'data' stamp: 'JulianBayardo 11/16/2017 20:26'!instanceCustomerDatabaseStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!ErpTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 14:21'!instancePepeSanchezWithAddresses	| customer |	customer := self instanceHomelessPepeSanchez.	customer		addAddress:			(Address				street: 'San Martin'				number: 3322				town: 'Olivos'				zipCode: 1636				province: 'BsAs').	customer		addAddress:			(Address				street: 'Maipu'				number: 888				town: 'Florida'				zipCode: 1122				province: 'Buenos Aires').	^ customer! !!ErpTest methodsFor: 'running' stamp: 'JulianBayardo 11/16/2017 20:24'!setUp	system := Enviroment current createErpSystem.	system start.	system beginTransaction! !!ErpTest methodsFor: 'running' stamp: 'JulianBayardo 11/16/2017 20:24'!tearDown	system commit.	system close! !ErpTest subclass: #CustomerImportTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 17:43'!test14whitespaceIsSkipped	| inputStream |	inputStream := self instanceWhitespaceSeparatedStream.	(CustomerImport into: system) import: inputStream.	self assert: system numberOfCustomers equals: 2.	self customerImportedWithAddresses: self instanceHomelessPepeSanchez.	self customerImportedWithAddresses: self instanceHomelessJuanPerez.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:41'!test02customerRecordMustHaveExactlyFiveFields	| inputStream |	inputStream := self instanceIncompleteCustomerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: ImportError description: Import customerRecordSizeMustBeFive.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:21'!test08addressStreetNumberIsANumber	| inputStream |	inputStream := self instanceStreetNumberNotAnIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: ImportError description: Import addressStreetNumberMustBeANumber.	self assert: system numberOfCustomers equals: 1.	self customerImportedWithAddresses: self instanceHomelessPepeSanchez.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 17:42'!test07newlineIsSkipped	| inputStream |	inputStream := self instanceNewLineSeparatedStream.	(CustomerImport into: system) import: inputStream.	self assert: system numberOfCustomers equals: 2.	self customerImportedWithAddresses: self instanceHomelessPepeSanchez.	self customerImportedWithAddresses: self instanceHomelessJuanPerez.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:36'!test06addressMustHaveCustomer	| inputStream |	inputStream := self instanceSingleAddressStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: ImportError description: Import addressMustHaveParty.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:36'!test12multipleRunsDoNotKeepCustomer	| inputStream importer inputStream2 |	importer := CustomerImport into: system.	inputStream := self instanceCustomerDatabaseStream.	importer import: inputStream.	inputStream close.	inputStream2 := self instanceSingleAddressStream.	self should: [ importer import: inputStream2 ] raise: ImportError description: Import addressMustHaveParty.	inputStream2 close.! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:39'!test03addressRecordMustHaveExactlySixFields	| inputStream |	inputStream := self instanceIncompleteAddressStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: ImportError description: Import addressRecordSizeMustBeSix.	self assert: system numberOfCustomers equals: 1.		self customerImportedWithAddresses: self instanceHomelessPepeSanchez.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:21'!test09addressStreetNumberIsPositive	| inputStream |	inputStream := self instanceStreetNumberNegativeIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: ImportError description: Import addressStreetNumberMustBePositive.	self assert: system numberOfCustomers equals: 1.	self customerImportedWithAddresses: self instanceHomelessPepeSanchez.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:16'!test00hasAllCustomers	| inputStream |	inputStream := self instanceCustomerDatabaseStream.	(CustomerImport into: system) import: inputStream.	self customerImportedWithAddresses: self instancePepeSanchezWithAddresses.	self customerImportedWithAddresses: self instanceJuanPerezWithAddress.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:21'!test05invalidAddressIdentifierGeneratesError	| inputStream |	inputStream := self instanceUnknownAddressRecordTypeStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: ImportError description: Import unknownRecordType.	self assert: system numberOfCustomers equals: 1.	self customerImportedWithAddresses: self instanceHomelessPepeSanchez.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 13:55'!test13addAlreadyExistingCustomerFails	| inputStream importer inputStream2 |	importer := CustomerImport into: system.	inputStream := self instanceCustomerDatabaseStream.	importer import: inputStream.	inputStream close.	inputStream2 := self instanceCustomerDatabaseStream.	self should: [ importer import: inputStream2 ] raise: ImportError description: Import customerAlreadyExists.	inputStream2 close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:21'!test11zipCodeIsPositive	| inputStream |	inputStream := self instanceZipCodeNegativeIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: ImportError description: Import zipCodeMustBePositive.	self assert: system numberOfCustomers equals: 1.	self customerImportedWithAddresses: self instanceHomelessPepeSanchez.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:21'!test10zipCodeIsANumber	| inputStream |	inputStream := self instanceZipCodeNotAnIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: ImportError description: Import zipCodeMustBeANumber.	self assert: system numberOfCustomers equals: 1.	self customerImportedWithAddresses: self instanceHomelessPepeSanchez.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:04'!test01emptyStreamDoesNotImport	| inputStream |	inputStream := self instanceEmptyStream.	(CustomerImport into: system) import: inputStream.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 13:55'!test04invalidCustomerIdentifierGeneratesError	| inputStream |	inputStream := self instanceUnknownCustomerRecordTypeStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: ImportError description: Import unknownRecordType.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:16'!instanceIncompleteCustomerStream	^ ReadStream on: 'C,Pepe,Sanchez,D,'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:15'!instanceEmptyStream	^ ReadStream on: ''! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:16'!instanceUnknownCustomerRecordTypeStream	^ ReadStream on: 'CC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 14:21'!instanceHomelessJuanPerez	^ Customer first: 'Juan' last: 'Perez' identification: (Identification number: '23-25666777-9' type: 'C')! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 14:21'!instanceJuanPerezWithAddress	| customer |	customer := self instanceHomelessJuanPerez.	customer		addAddress:			(Address				street: 'Alem'				number: 1122				town: 'CABA'				zipCode: 1001				province: 'CABA').	^ customer! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 17:43'!instanceWhitespaceSeparatedStream	^ ReadStream		on:			'C     ,     Pepe,          Sanchez       , D,    22333444     C        , Juan       ,  Perez    ,C,23-25666777-9'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:17'!instanceUnknownAddressRecordTypeStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 22:49'!instanceZipCodeNotAnIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,2233,Olivos,12ss,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:17'!instanceSingleAddressStream	^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:16'!instanceIncompleteAddressStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 17:42'!instanceNewLineSeparatedStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444     C,Juan,Perez,C,23-25666777-9'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 22:25'!instanceStreetNumberNegativeIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,-33,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 22:49'!instanceZipCodeNegativeIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,2233,Olivos,-21,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:18'!instanceStreetNumberNotAnIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,2ll322,Olivos,1636,BsAs'! !Object subclass: #Identification	instanceVariableNames: 'identificationNumber identificationType'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Identification methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 20:00'!= anIdentification	^ self type = anIdentification type and: self number = anIdentification number! !!Identification methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 19:59'!hash	^ self type hash bitXor: self number hash! !!Identification methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:51'!number	^ identificationNumber! !!Identification methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:51'!type	^ identificationType! !!Identification methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:52'!initializeNumber: anIdNumber type: anIdType	identificationNumber := anIdNumber .	identificationType := anIdType .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Identification class	instanceVariableNames: ''!!Identification class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 19:52'!number: anIdNumber type: anIdType	^ self new initializeNumber: anIdNumber type: anIdType.! !Object subclass: #Import	instanceVariableNames: 'inputStream currentLine record system newParty'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Import methodsFor: 'parsing' stamp: 'DamianFurman 11/22/2017 20:59'!import: aStream	inputStream := aStream.	newParty := nil.	[ self readNextLine ]		whileTrue: [ currentLine isEmpty				ifFalse: [ self createRecordFromLine.					self parseRecord ] ]! !!Import methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 17:34'!handlers	| mapping |	mapping := Dictionary new.	mapping at: 'A' put: #processAddressRecord.	^ mapping! !!Import methodsFor: 'parsing - private' stamp: 'DamianFurman 11/22/2017 21:14'!readNextLine	| hasNextLine |	currentLine := inputStream nextLine.	hasNextLine := currentLine notNil.		hasNextLine ifTrue: [ currentLine := currentLine trim ].	^ hasNextLine! !!Import methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 17:45'!createRecordFromLine	record := (currentLine substrings: {$,}) collect: [ :aPiece | aPiece trim ].	^ record! !!Import methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 16:51'!parseAddress	| streetNumber zipCode |	record size = 6		ifFalse: [ ImportError new signal: self class addressRecordSizeMustBeSix ].	streetNumber := record third.	" Esto se hace con regex porque asInteger parsea el primer digito que encuentra. "	(streetNumber matchesRegex: '-?[0-9]+')		ifFalse: [ ImportError new signal: self class addressStreetNumberMustBeANumber ].	streetNumber := streetNumber asInteger.	zipCode := record fifth.	(zipCode matchesRegex: '-?[0-9]+')		ifFalse: [ ImportError new signal: self class zipCodeMustBeANumber ].	zipCode := zipCode asInteger.	^ Address		street: record second		number: streetNumber		town: record fourth		zipCode: zipCode		province: record sixth! !!Import methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 17:18'!processAddressRecord	newParty isNil		ifTrue: [ ImportError new signal: self class addressMustHaveParty ].	newParty addAddress: self parseAddress! !!Import methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 14:41'!parseCustomer	record size = 5		ifFalse: [ ImportError new signal: self class customerRecordSizeMustBeFive ].	^ Customer		first: record second		last: record third		identification: (Identification number: record fifth type: record fourth).! !!Import methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 17:34'!parseRecord	| selector |	selector := self handlers at: record first ifAbsent: [ ImportError new signal: self class unknownRecordType ].	(Message selector: selector) sendTo: self! !!Import methodsFor: 'initialization' stamp: 'DamianFurman 11/22/2017 20:59'!initializeInto: aSystem	system := aSystem.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Import class	instanceVariableNames: ''!!Import class methodsFor: 'instance creation' stamp: 'DamianFurman 11/9/2017 21:40'!into: aDatabase	^ super new initializeInto: aDatabase.! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/23/2017 14:41'!supplierRecordSizeMustBeFour	^ 'Supplier record must have exactly four fields'! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/22/2017 16:14'!customerAlreadyExists	^ 'Attempted to create a new customer, but it already exists'.! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/23/2017 14:39'!addressRecordSizeMustBeSix	^ 'Address record length should always be 6'! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/23/2017 14:41'!customerRecordSizeMustBeFive	^ 'Customer record length should always be 5'.! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/13/2017 20:58'!addressStreetNumberMustBeANumber	^ 'Address must have a positive integer as street number.'! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/22/2017 19:08'!existingCustomerMustHaveSupplier	^ 'Existing customer record must have a supplier'! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/22/2017 15:33'!newCustomerAlreadyExists	^ 'Attempted to add a new customer for a supplier, but it already exists'! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/13/2017 22:49'!zipCodeMustBePositive	^ 'Zip code must be a positive number'! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/22/2017 19:22'!newCustomerMustHaveSupplier	^ 'New customer must have a supplier'! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/23/2017 14:40'!supplierAlreadyExists	^ 'Attempted to import already existing supplier'.! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/13/2017 18:59'!unknownRecordType	^ 'Record begins with invalid identifier'! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/23/2017 14:36'!addressMustHaveParty	^ 'Attempt to import address without a Party'! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/13/2017 22:25'!addressStreetNumberMustBePositive	^ 'Street number for address must be a positive integer'.! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/23/2017 14:42'!existingCustomerDoesNotExist	^ 'Customer should exist but does not'.! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/13/2017 22:45'!zipCodeMustBeANumber	^ 'Zip code must be a number'! !!Import class methodsFor: 'error reporting' stamp: 'JulianBayardo 11/23/2017 14:40'!existingCustomerRecordSizeMustBeThree	^ 'Existing customer record must have exactly three fields'.! !Import subclass: #CustomerImport	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImport methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 17:34'!handlers	| mapping |	mapping := super handlers.	mapping at: 'C' put: #processCustomerRecord.	^ mapping! !!CustomerImport methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 17:13'!processCustomerRecord	newParty := self parseCustomer.	system		fetchSingleCustomerByIdentification: newParty identification		ifNone: [ system addCustomer: newParty.			^ nil ].	ImportError new signal: self class customerAlreadyExists! !Exception subclass: #ImportError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!Object subclass: #Party	instanceVariableNames: 'addresses identification id'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/23/2017 13:40'!= aParty	^ self identification = aParty identification and: (self addresses = aParty addresses)! !!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 19:34'!addAddress: anAddress 	addresses add: anAddress ! !!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 20:47'!addresses	^ addresses! !!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 20:51'!hash	^ self identification hash! !!Party methodsFor: 'identification' stamp: 'JulianBayardo 11/16/2017 19:54'!identification	^ identification! !!Party methodsFor: 'initialization' stamp: 'JulianBayardo 11/16/2017 20:47'!initialize	addresses := Set new! !!Party methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 18:43'!initializeIdentification: anIdentification	identification := anIdentification .! !Party subclass: #Customer	instanceVariableNames: 'firstName lastName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 18:44'!initializeFirst: aFirstName last: aLastName identification: anIdentification	firstName := aFirstName.	lastName := aLastName.	self initializeIdentification: anIdentification .! !!Customer methodsFor: 'comparing' stamp: 'JulianBayardo 11/16/2017 19:42'!= aCustomer	^ (super = aCustomer and: (self firstName = aCustomer firstName and: self lastName = aCustomer lastName))! !!Customer methodsFor: 'comparing' stamp: 'JulianBayardo 11/16/2017 19:43'!hash	^ (super hash bitXor: (self firstName hash bitXor: self lastName hash))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Customer class	instanceVariableNames: ''!!Customer class methodsFor: 'accessing' stamp: 'JulianBayardo 11/22/2017 18:46'!first: aFirstName last: aLastName identification: anIdentification	^ self new		initializeFirst: aFirstName		last: aLastName		identification: anIdentification.! !Enviroment subclass: #ProductionEnviroment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ProductionEnviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/23/2017 16:34'!createErpSystem	^ ErpSystem customers: PersistentCustomerSystem new suppliers: PersistentSupplierSystem new! !Party subclass: #Supplier	instanceVariableNames: 'name customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/16/2017 20:51'!hash	^ super hash bitXor: (self name hash)! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 18:50'!initializeName: aName identification: anIdentification	name := aName.	self initializeIdentification: anIdentification .! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/16/2017 19:18'!name	^ name.! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/23/2017 13:52'!= aSupplier	^ super = aSupplier and: (self name = aSupplier name and: self customers = aSupplier customers).! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 15:59'!initialize	super initialize.	customers := Set new! !!Supplier methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:49'!customers	^ customers.! !!Supplier methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 20:46'!addCustomer: aCustomer 	customers add: aCustomer.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Supplier class	instanceVariableNames: ''!!Supplier class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 18:50'!name: aName identification: anIdentification	^ self new initializeName: aName identification: anIdentification! !Import subclass: #SupplierImport	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SupplierImport methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 17:38'!processExistingCustomerRecord	| identification customer |	newParty isNil		ifTrue: [ ImportError new signal: self class existingCustomerMustHaveSupplier ].	identification := self parseExistingCustomerIdentification.	customer := system fetchSingleCustomerByIdentification: identification ifNone: [ ImportError new signal: self class existingCustomerDoesNotExist ].	newParty addCustomer: customer! !!SupplierImport methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 14:41'!parseSupplier	record size = 4		ifFalse: [ ImportError new signal: self class supplierRecordSizeMustBeFour ].	^ Supplier name: record second identification: (Identification number: record fourth type: record third).! !!SupplierImport methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 17:34'!handlers	| mapping |	mapping := super handlers.	mapping at: 'NC' put: #processNewCustomerRecord.	mapping at: 'EC' put: #processExistingCustomerRecord.	mapping at: 'S' put: #processSupplierRecord.	^ mapping! !!SupplierImport methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 14:40'!parseExistingCustomerIdentification	record size = 3		ifFalse: [ ImportError new signal: self class existingCustomerRecordSizeMustBeThree ].	^ Identification number: record third type: record second! !!SupplierImport methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 17:17'!processNewCustomerRecord	| newCustomer |	newParty isNil		ifTrue: [ ImportError new signal: self class newCustomerMustHaveSupplier ].	newCustomer := self parseCustomer.	system		fetchSingleCustomerByIdentification: newCustomer identification		ifNone: [ system addCustomer: newCustomer.			newParty addCustomer: newCustomer.			^ nil ].	ImportError new signal: self class newCustomerAlreadyExists! !!SupplierImport methodsFor: 'parsing - private' stamp: 'JulianBayardo 11/23/2017 17:16'!processSupplierRecord	newParty := self parseSupplier.	system		fetchSingleSupplierByIdentification: newParty identification		ifNone: [ system addSupplier: newParty.			^ nil ].	ImportError new signal: self class supplierAlreadyExists! !ErpTest subclass: #SupplierImportTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:40'!test14importAlreadyExistingSupplierFails	| inputStream supplier |	inputStream := ReadStream		on:			'S,Supplier1,D,123		S,Supplier1,D,123'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: ImportError description: Import supplierAlreadyExists.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 2.	supplier := self supplierImportedWithAddressesAndCustomers: self instanceSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:41'!test01supplierRecordMustHaveExactlyFourFields	| inputStream |	inputStream := ReadStream on: 'S,Supplier1,D'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: ImportError description: Import supplierRecordSizeMustBeFour.	self assert: system hasNoSuppliers.	inputStream close.! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:28'!test07importSupplierWithNewCustomer	| inputStream supplier customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		NC,Domingo,Sanchez,D,444444'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 3.	supplier := self supplierImported: self instanceSupplier.	customer := system fetchSingleCustomerByIdentification: (Identification number: '444444' type: 'D') ifNone: [ self fail ].	self assert: (supplier customers includes: customer).	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 13:55'!test12importNewCustomerWithoutSupplierShouldFail	| inputStream |	inputStream := ReadStream		on:			'NC,Domingo,Sanchez,D,444444'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: ImportError description: Import newCustomerMustHaveSupplier.	self assert: system numberOfSuppliers equals: 0.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:42'!test03importSupplierWithExistingCustomerThatDoesNotExistShouldFail	| inputStream |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D,54R4K47UN64'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: ImportError description: Import existingCustomerDoesNotExist.	self assert: system numberOfSuppliers equals: 1.	self supplierImportedWithAddressesAndCustomers: self instanceSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 15:32'!test05importSupplierWithExistingCustomer	| inputStream |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D,22333444'.	system fetchSingleCustomerByIdentification: (Identification number: '22333444' type: 'D') ifNone: [ self fail ].	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 2.	self supplierImportedWithAddressesAndCustomers: self instanceSupplierWithComplexPepeSanchez.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:27'!test13importCustomerUsingSupplierImporterShoudBeRecordUnknown	| inputStream |	inputStream := ReadStream		on:			'C,Bondiola,Sanchez,D,66333444'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: ImportError description: Import unknownRecordType .	self assert: system numberOfSuppliers equals: 0.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 13:55'!test11importExistingCustomerWithoutSupplierShouldFail	| inputStream |	inputStream := ReadStream on: 'EC,D,22333444'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: ImportError description: Import existingCustomerMustHaveSupplier.	self assert: system numberOfSuppliers equals: 0.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 13:58'!test00importSupplier	| inputStream |	inputStream := ReadStream on: 'S,Supplier1,D,123'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self supplierImportedWithAddressesAndCustomers: self instanceSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:28'!test06importSupplierWithNewCustomerAlreadyExistingShoudFail	| inputStream supplier customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		NC,Pepe,Sanchez,D,22333444'.	customer := system fetchSingleCustomerByIdentification: (Identification number: '22333444' type: 'D') ifNone: [ self fail ].	self should: [ (SupplierImport into: system) import: inputStream ] raise: ImportError description: Import newCustomerAlreadyExists.	self assert: system numberOfSuppliers equals: 1.	supplier := self supplierImported: self instanceSupplier.	self assert: (supplier customers includes: customer) not.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:40'!test04existingCustomerRecordMustHaveExactlyThreeFields	| inputStream |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: ImportError description: Import existingCustomerRecordSizeMustBeThree.	self assert: system numberOfSuppliers equals: 1.	self supplierImportedWithAddressesAndCustomers: self instanceSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 13:58'!test08importSupplierWithAddress	| inputStream |	inputStream := ReadStream		on:			'S,Supplier1,D,123		A,San Martin,222222,Olivos,1636,BsAs'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 2.	self supplierImportedWithAddressesAndCustomers: self instanceSupplierWithAddress.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 13:55'!test02invalidSupplierIdentifierGeneratesError	| inputStream |	inputStream := ReadStream on: 'SARACATUNGA,Supplier1,D,123'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: ImportError description: Import unknownRecordType.	self assert: system hasNoSuppliers.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:22'!test09importSupplierWithNewCustomerAndAddress	| inputStream |	inputStream := ReadStream		on:			'S,Supplier1,D,123		NC,Domingo,Sanchez,D,444444		A,San Martin,222222,Olivos,1636,BsAs'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 3.	self customerImportedWithAddresses: self instanceHomelessDomingoSanchez.	self supplierImportedWithAddressesAndCustomers: self instanceSupplierWithAddressAndDomingoSanchez.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'JulianBayardo 11/23/2017 14:26'!test10importSupplierWithExistingCustomerAndAddress	| inputStream  |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D,22333444		A,San Martin,222222,Olivos,1636,BsAs'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 2.	self supplierImportedWithAddressesAndCustomers: self instanceSupplierWithAddressAndComplexPepeSanchez.	inputStream close! !!SupplierImportTest methodsFor: 'running' stamp: 'DamianFurman 11/23/2017 11:52'!setUp	super setUp.	(CustomerImport into: system) import: (self instanceCustomerDatabaseStream ).! !!SupplierImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 14:22'!instanceHomelessDomingoSanchez	^ Customer first: 'Domingo' last: 'Sanchez' identification: (Identification number: '444444' type: 'D')! !!SupplierImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 14:25'!instanceSupplierWithAddressAndComplexPepeSanchez	| supplier |	supplier := self instanceSupplierWithAddress.	supplier addCustomer: self instancePepeSanchezWithAddresses.	^ supplier! !!SupplierImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 13:58'!instanceSupplierWithAddress	| supplier |	supplier := self instanceSupplier.	supplier addAddress: (Address		street: 'San Martin'		number: 222222		town: 'Olivos'		zipCode: 1636		province: 'BsAs').	^ supplier! !!SupplierImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 13:58'!instanceSupplier	^ Supplier name: 'Supplier1' identification: (Identification number: '123' type: 'D').! !!SupplierImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 14:06'!instanceSupplierWithComplexPepeSanchez	| supplier |	supplier := self instanceSupplier.	supplier addCustomer: self instancePepeSanchezWithAddresses.	^ supplier! !!SupplierImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/23/2017 14:22'!instanceSupplierWithAddressAndDomingoSanchez	| supplier |	supplier := self instanceSupplierWithAddress.	supplier addCustomer: self instanceHomelessDomingoSanchez.	^ supplier! !!SupplierImportTest methodsFor: 'testing' stamp: 'JulianBayardo 11/23/2017 14:28'!supplierImportedWithAddressesAndCustomers: anExpectedSupplier	| supplier |	supplier := system fetchSingleSupplierByIdentification: anExpectedSupplier identification ifNone: [ self fail ].	self assert: supplier equals: anExpectedSupplier.	^ supplier! !!SupplierImportTest methodsFor: 'testing' stamp: 'JulianBayardo 11/23/2017 14:28'!supplierImported: anExpectedSupplier	| supplier |	supplier := system fetchSingleSupplierByIdentification: anExpectedSupplier identification ifNone: [ self fail ].	self assert: supplier name equals: anExpectedSupplier name.	^ supplier! !Enviroment subclass: #TestEnviroment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TestEnviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/23/2017 16:06'!createErpSystem	^ ErpSystem customers: TransientSystem new suppliers: TransientSystem new! !!TestEnviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/23/2017 16:46'!isActive	^ true.! !Object subclass: #TransactionalSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TransactionalSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:06'!beginTransaction	self subclassResponsibility! !!TransactionalSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:06'!close	self subclassResponsibility	! !!TransactionalSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:07'!start	self subclassResponsibility ! !!TransactionalSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:06'!commit	self subclassResponsibility! !TransactionalSystem subclass: #ErpSystem	instanceVariableNames: 'customerSystem supplierSystem'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/23/2017 15:59'!customers	^ customerSystem! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/23/2017 15:59'!suppliers	^ supplierSystem! !!ErpSystem methodsFor: 'testing' stamp: 'JulianBayardo 11/23/2017 17:59'!hasNoSuppliers	" Este inline no se puede hacer automatico y queda poco tiempo. "	^ self suppliers isEmpty! !!ErpSystem methodsFor: 'testing' stamp: 'JulianBayardo 11/23/2017 17:59'!hasNoCustomers	" Este inline no se puede hacer automatico y queda poco tiempo. "	^ self customers isEmpty! !!ErpSystem methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/23/2017 17:59'!fetchSingleSupplierByIdentification: anIdentification ifNone: aBlockClosure	" Este inline no se puede hacer automatico y queda poco tiempo. "	^ self suppliers fetchById: anIdentification ifNone: aBlockClosure! !!ErpSystem methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/23/2017 17:59'!fetchSingleCustomerByIdentification: anIdentification ifNone: aBlockClosure	" Este inline no se puede hacer automatico y queda poco tiempo. "	^ self customers fetchById: anIdentification ifNone: aBlockClosure! !!ErpSystem methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/23/2017 17:59'!numberOfSuppliers	" Este inline no se puede hacer automatico y queda poco tiempo. "	^ self suppliers size! !!ErpSystem methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/23/2017 17:59'!numberOfCustomers	" Este inline no se puede hacer automatico y queda poco tiempo. "	^ self customers size! !!ErpSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:09'!beginTransaction	self customers beginTransaction .	self suppliers beginTransaction. ! !!ErpSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:08'!start	self customers start.	self suppliers start.! !!ErpSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:08'!close	self customers close.	self suppliers close.! !!ErpSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:08'!commit	self customers commit.	self suppliers commit.! !!ErpSystem methodsFor: 'initialization' stamp: 'JulianBayardo 11/23/2017 16:03'!initializeCustomers: aCustomerSystem suppliers: aSupplierSystem	customerSystem := aCustomerSystem.	supplierSystem := aSupplierSystem! !!ErpSystem methodsFor: 'adding' stamp: 'JulianBayardo 11/23/2017 17:59'!addSupplier: aSupplier	" Este inline no se puede hacer automatico y queda poco tiempo. "	self suppliers add: aSupplier! !!ErpSystem methodsFor: 'adding' stamp: 'JulianBayardo 11/23/2017 17:59'!addCustomer: aCustomer	" Este inline no se puede hacer automatico y queda poco tiempo. "	self customers add: aCustomer! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ErpSystem class	instanceVariableNames: ''!!ErpSystem class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/23/2017 16:02'!customers: aCustomerSystem suppliers: aSupplierSystem	^ self new initializeCustomers: aCustomerSystem suppliers: aSupplierSystem .! !TransactionalSystem subclass: #TransactionalStorageSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TransactionalStorageSystem methodsFor: 'adding' stamp: 'JulianBayardo 11/23/2017 15:49'!add: anObject	self subclassResponsibility ! !!TransactionalStorageSystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/23/2017 15:55'!select: aBlockClosure	^ self all select: aBlockClosure.! !!TransactionalStorageSystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/23/2017 16:13'!fetchById: anIdentification ifNone: aBlock	| results |	results := self select: [ :anObject | anObject identification = anIdentification ].	results size = 0		ifTrue: aBlock.	^ results at: 1.! !!TransactionalStorageSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/23/2017 15:55'!size	^ self all size.! !!TransactionalStorageSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/23/2017 15:42'!all	self subclassResponsibility 	! !!TransactionalStorageSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/23/2017 16:36'!isEmpty	^ self all isEmpty.! !TransactionalStorageSystem subclass: #PersistentSystem	instanceVariableNames: 'session targetClass'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PersistentSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/23/2017 16:29'!all	^ session selectAllOfType: targetClass.! !!PersistentSystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/23/2017 16:28'!select: aBlockClosure	^ session select: aBlockClosure ofType: targetClass.! !!PersistentSystem methodsFor: 'mapping' stamp: 'JulianBayardo 11/23/2017 16:32'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identification)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentSystem methodsFor: 'mapping' stamp: 'JulianBayardo 11/23/2017 16:33'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #name)				with: (EmbededMapping withDefaultFieldNameFor: #identification)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentSystem methodsFor: 'mapping' stamp: 'JulianBayardo 11/23/2017 16:32'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentSystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/23/2017 16:18'!beginTransaction	session beginTransaction ! !!PersistentSystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/23/2017 16:17'!commit	session commit! !!PersistentSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:18'!close	session close.! !!PersistentSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:17'!start	session open.! !!PersistentSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:30'!initializeFor: aClass	targetClass := aClass! !!PersistentSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 16:17'!initialize	session := DataBaseSession		for:			(Array				with: self addressMapping				with: self customerMapping				with: self supplierMapping)! !!PersistentSystem methodsFor: 'adding' stamp: 'JulianBayardo 11/23/2017 16:27'!add: anObject	session persist: anObject.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PersistentSystem class	instanceVariableNames: ''!!PersistentSystem class methodsFor: 'instance creation' stamp: 'JulianBayardo 11/23/2017 16:30'!for: aClass	^ super new initializeFor: aClass.! !PersistentSystem subclass: #PersistentCustomerSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PersistentCustomerSystem class	instanceVariableNames: ''!!PersistentCustomerSystem class methodsFor: 'instance creation' stamp: 'JulianBayardo 11/23/2017 16:30'!new	^ super for: Customer. ! !PersistentSystem subclass: #PersistentSupplierSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PersistentSupplierSystem class	instanceVariableNames: ''!!PersistentSupplierSystem class methodsFor: 'instance creation' stamp: 'JulianBayardo 11/23/2017 16:31'!new	^ super for: Supplier.! !TransactionalStorageSystem subclass: #TransientSystem	instanceVariableNames: 'database'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TransientSystem methodsFor: 'adding' stamp: 'JulianBayardo 11/23/2017 15:52'!add: anObject	database add: anObject! !!TransientSystem methodsFor: 'adding' stamp: 'JulianBayardo 11/23/2017 15:47'!beginTransaction! !!TransientSystem methodsFor: 'adding' stamp: 'JulianBayardo 11/23/2017 15:47'!commit! !!TransientSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/23/2017 15:52'!all	^ database! !!TransientSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 15:47'!close! !!TransientSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/23/2017 15:52'!start	database := OrderedCollection new.! !