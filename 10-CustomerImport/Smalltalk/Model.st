Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 18:58'!initializeStreet: aStreetName number: aStreetNumber town: aTownName province: aProvinceName zipCode: aZipCode	aStreetNumber > 0		ifFalse: [ PartyImportError new signal: PartyImport addressStreetNumberMustBePositive ].	aZipCode > 0		ifFalse: [ PartyImportError new signal: PartyImport zipCodeMustBePositive ].	streetName := aStreetName.	streetNumber := aStreetNumber.	town := aTownName.	province := aProvinceName.	zipCode := aZipCode! !!Address methodsFor: 'comparing' stamp: 'JulianBayardo 11/7/2017 00:00'!= anAddress	^ self streetName = anAddress streetName and: (self streetNumber = anAddress streetNumber and: (self town = anAddress town and: (self zipCode = anAddress zipCode and: (self province = anAddress province)))).! !!Address methodsFor: 'comparing' stamp: 'JulianBayardo 11/7/2017 00:08'!hash	^ self streetName hash		bitXor:			(self streetNumber hash bitXor: (self town hash bitXor: (self zipCode hash bitXor: self province hash)))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Address class	instanceVariableNames: ''!!Address class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 19:34'!street: aStreetName number: aStreetNumber town: aTownName zipCode: aZipCode province: aProvinceName	^ self new initializeStreet: aStreetName number: aStreetNumber town: aTownName province: aProvinceName zipCode: aZipCode! !Object subclass: #Enviroment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Enviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:07'!createErpSystem	self subclassResponsibility .! !!Enviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/13/2017 22:28'!isActive	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Enviroment class	instanceVariableNames: ''!!Enviroment class methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 18:02'!current	^ (self subclasses collect: [ :aClass | aClass new ])		detect: [ :anEnvironment | anEnvironment isActive ]		ifFound: [ :anEnvironment | ^ anEnvironment ]		ifNone: [ ^ TestEnviroment new ].! !Object subclass: #ErpSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ErpSystem methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 20:03'!fetchSupplierByIdentification: anIdentification ifNone: aBlockClosure	| suppliers |	suppliers := self selectSuppliers: [ :aSupplier | aSupplier identification = anIdentification ].	suppliers isEmpty		ifTrue: [ ^ aBlockClosure value ].	^ suppliers at: 1! !!ErpSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/13/2017 22:32'!close	self subclassResponsibility 	! !!ErpSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/13/2017 22:32'!start	self subclassResponsibility .! !!ErpSystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/16/2017 19:21'!selectCustomers: aBlockClosure	self subclassResponsibility .		! !!ErpSystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/16/2017 19:22'!selectSuppliers: aBlockClosure	self subclassResponsibility! !!ErpSystem methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:02'!fetchCustomerByIdentification: anIdentification ifNone: aBlock	| customers |	customers := self selectCustomers: [ :aCustomer | aCustomer identification = anIdentification ].	customers size = 0		ifTrue: [ ^ aBlock value ].	^ customers at: 1! !!ErpSystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 22:31'!beginTransaction	self subclassResponsibility! !!ErpSystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/16/2017 19:47'!addCustomer: aCustomer	self subclassResponsibility! !!ErpSystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 22:32'!commit	self subclassResponsibility ! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:17'!hasNoSuppliers	^ self numberOfSuppliers = 0! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:29'!allCustomers	self subclassResponsibility.! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:17'!numberOfSuppliers	^ self allSuppliers size! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:17'!allSuppliers	self subclassResponsibility .! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:48'!numberOfCustomers	^ self allCustomers size! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:48'!hasNoCustomers	^ self numberOfCustomers = 0.! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:30'!addSupplier: aSupplier	self subclassResponsibility .! !TestCase subclass: #ErpTest	instanceVariableNames: 'system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ErpTest methodsFor: 'data' stamp: 'JulianBayardo 11/16/2017 20:26'!instanceCustomerDatabaseStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!ErpTest methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:24'!customerImportedWithAddresses: anExpectedCustomer	| customer |	customer := self customerImported: anExpectedCustomer.	self assert: customer addresses equals: anExpectedCustomer addresses.	^ customer.! !!ErpTest methodsFor: 'testing' stamp: 'JulianBayardo 11/22/2017 15:37'!should: aBlock raise: anExceptionClass description: anExpectedDescription	^ self should: aBlock raise: anExceptionClass withExceptionDo: [ :anException | self assert: anException messageText equals: anExpectedDescription ]! !!ErpTest methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:24'!customerImported: anExpectedCustomer	| customer |	customer := system fetchCustomerByIdentification: anExpectedCustomer identification ifNone: [ self fail ].	self assert: customer equals: anExpectedCustomer.	^ customer! !!ErpTest methodsFor: 'running' stamp: 'JulianBayardo 11/16/2017 20:24'!setUp	system := Enviroment current createErpSystem.	system start.	system beginTransaction! !!ErpTest methodsFor: 'running' stamp: 'JulianBayardo 11/16/2017 20:24'!tearDown	system commit.	system close! !ErpTest subclass: #CustomerImportTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 22:49'!instanceZipCodeNegativeIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,2233,Olivos,-21,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 22:49'!instanceZipCodeNotAnIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,2233,Olivos,12ss,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 22:25'!instanceStreetNumberNegativeIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,-33,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:18'!instanceStreetNumberNotAnIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,2ll322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:17'!instanceUnknownAddressRecordTypeStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:17'!instanceWhitespaceSeparatedStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444     C,Juan,Perez,C,23-25666777-9'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:16'!instanceIncompleteCustomerStream	^ ReadStream on: 'C,Pepe,Sanchez,D,'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:17'!instanceSingleAddressStream	^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:16'!instanceIncompleteAddressStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:15'!instanceEmptyStream	^ ReadStream on: ''! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/22/2017 19:34'!instanceJuanPerez	| customer |	customer := Customer		first: 'Juan'		last: 'Perez'		identification: (Identification number: '23-25666777-9' type: 'C').	customer		addAddress:			(Address				street: 'Alem'				number: 1122				town: 'CABA'				zipCode: 1001				province: 'CABA').	^ customer! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/22/2017 19:34'!instancePepeSanchez	| customer |	customer := Customer		first: 'Pepe'		last: 'Sanchez'		identification: (Identification number: '22333444' type: 'D').	customer		addAddress:			(Address				street: 'San Martin'				number: 3322				town: 'Olivos'				zipCode: 1636				province: 'BsAs').	customer		addAddress:			(Address				street: 'Maipu'				number: 888				town: 'Florida'				zipCode: 1122				province: 'Buenos Aires').	^ customer! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:16'!instanceUnknownCustomerRecordTypeStream	^ ReadStream on: 'CC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:05'!test02customerRecordMustHaveExactlyFiveFields	| inputStream |	inputStream := self instanceIncompleteCustomerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport customerRecordSizeError.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test10zipCodeIsANumber	| inputStream |	inputStream := self instanceZipCodeNotAnIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport zipCodeMustBeANumber.	self customerImported: self instancePepeSanchez.	self assert: system numberOfCustomers equals: 1.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:10'!test12multipleRunsDoNotKeepCustomer	| inputStream importer inputStream2 |	importer := CustomerImport into: system.	inputStream := self instanceCustomerDatabaseStream.	importer import: inputStream.	inputStream close.	inputStream2 := self instanceSingleAddressStream.	self should: [ importer import: inputStream2 ] raise: PartyImportError description: PartyImport addressMustHaveCustomer.	inputStream2 close.! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:04'!test01emptyStreamDoesNotImport	| inputStream |	inputStream := self instanceEmptyStream.	(CustomerImport into: system) import: inputStream.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:10'!test13addAlreadyExistingCustomerFails	| inputStream importer inputStream2 |	importer := CustomerImport into: system.	inputStream := self instanceCustomerDatabaseStream.	importer import: inputStream.	inputStream close.	inputStream2 := self instanceCustomerDatabaseStream.	self should: [ importer import: inputStream2 ] raise: PartyImportError description: PartyImport customerAlreadyExists.	inputStream2 close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test05invalidAddressIdentifierGeneratesError	| inputStream |	inputStream := self instanceUnknownAddressRecordTypeStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport unknownRecordType.	self customerImported: self instancePepeSanchez.	self assert: system numberOfCustomers equals: 1.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test08addressStreetNumberIsANumber	| inputStream |	inputStream := self instanceStreetNumberNotAnIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport addressStreetNumberMustBeANumber.	self customerImported: self instancePepeSanchez.	self assert: system numberOfCustomers equals: 1.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test11zipCodeIsPositive	| inputStream |	inputStream := self instanceZipCodeNegativeIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport zipCodeMustBePositive.	self customerImported: self instancePepeSanchez.		self assert: system numberOfCustomers equals: 1.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:05'!test04invalidCustomerIdentifierGeneratesError	| inputStream |	inputStream := self instanceUnknownCustomerRecordTypeStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport unknownRecordType.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test07whitespaceIsSkipped	| inputStream |	inputStream := self instanceWhitespaceSeparatedStream.	(CustomerImport into: system) import: inputStream.	self customerImported: self instancePepeSanchez.	self customerImported: self instanceJuanPerez.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test06addressMustHaveCustomer	| inputStream |	inputStream := self instanceSingleAddressStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport addressMustHaveCustomer.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:04'!test00hasAllCustomers	| inputStream |	inputStream := self instanceCustomerDatabaseStream.	(CustomerImport into: system) import: inputStream.	self customerImportedWithAddresses: self instancePepeSanchez.	self customerImportedWithAddresses: self instanceJuanPerez.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:05'!test03addressRecordMustHaveExactlySixFields	| inputStream |	inputStream := self instanceIncompleteAddressStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport addressRecordSizeError.	self customerImported: self instancePepeSanchez.		self assert: system numberOfCustomers equals: 1.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test09addressStreetNumberIsPositive	| inputStream |	inputStream := self instanceStreetNumberNegativeIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport addressStreetNumberMustBePositive.	self customerImported: self instancePepeSanchez.	self assert: system numberOfCustomers equals: 1.	inputStream close! !Object subclass: #Identification	instanceVariableNames: 'identificationNumber identificationType'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Identification methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:51'!number	^ identificationNumber! !!Identification methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:51'!type	^ identificationType! !!Identification methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:52'!initializeNumber: anIdNumber type: anIdType	identificationNumber := anIdNumber .	identificationType := anIdType .! !!Identification methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 20:00'!= anIdentification	^ self type = anIdentification type and: self number = anIdentification number! !!Identification methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 19:59'!hash	^ self type hash bitXor: self number hash! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Identification class	instanceVariableNames: ''!!Identification class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 19:52'!number: anIdNumber type: anIdType	^ self new initializeNumber: anIdNumber type: anIdType.! !Object subclass: #Party	instanceVariableNames: 'addresses identificationNumber identificationType identification'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Party methodsFor: 'identification' stamp: 'JulianBayardo 11/16/2017 19:54'!identification	^ identification! !!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 20:51'!= aParty	^ self identification = aParty identification! !!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 20:47'!addresses	^ addresses! !!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 20:51'!hash	^ self identification hash! !!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 19:34'!addAddress: anAddress 	addresses add: anAddress ! !!Party methodsFor: 'initialization' stamp: 'JulianBayardo 11/16/2017 20:47'!initialize	addresses := Set new! !!Party methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 18:43'!initializeIdentification: anIdentification	identification := anIdentification .! !Party subclass: #Customer	instanceVariableNames: 'firstName lastName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Customer methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 18:44'!initializeFirst: aFirstName last: aLastName identification: anIdentification	firstName := aFirstName.	lastName := aLastName.	self initializeIdentification: anIdentification .! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'comparing' stamp: 'JulianBayardo 11/16/2017 19:42'!= aCustomer	^ (super = aCustomer and: (self firstName = aCustomer firstName and: self lastName = aCustomer lastName))! !!Customer methodsFor: 'comparing' stamp: 'JulianBayardo 11/16/2017 19:43'!hash	^ (super hash bitXor: (self firstName hash bitXor: self lastName hash))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Customer class	instanceVariableNames: ''!!Customer class methodsFor: 'accessing' stamp: 'JulianBayardo 11/22/2017 18:46'!first: aFirstName last: aLastName identification: anIdentification	^ self new		initializeFirst: aFirstName		last: aLastName		identification: anIdentification.! !Object subclass: #PartyImport	instanceVariableNames: 'inputStream currentLine record system newParty'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PartyImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 20:59'!import: aStream	inputStream := aStream.	newParty := nil.	[ self readNextLine ]		whileTrue: [ currentLine isEmpty				ifFalse: [ self createRecordFromLine.					self parseRecord ] ]! !!PartyImport methodsFor: 'data' stamp: 'DamianFurman 11/23/2017 11:30'!parseCustomer	record size = 5		ifFalse: [ PartyImportError new signal: self class customerRecordSizeError ].	^ Customer		first: record second		last: record third		identification: (Identification number: record fifth type: record fourth).! !!PartyImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 20:59'!createRecordFromLine	record := currentLine substrings: {$,}.	^ record! !!PartyImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 21:01'!parseAddress	| streetNumber zipCode |	newParty isNil		ifTrue: [ PartyImportError new signal: self class addressMustHaveCustomer ].	record size = 6		ifFalse: [ PartyImportError new signal: self class addressRecordSizeError ].	streetNumber := record third.	" Esto se hace con regex porque asInteger parsea el primer digito que encuentra. "	(streetNumber matchesRegex: '-?[0-9]+')		ifFalse: [ PartyImportError new				signal: self class addressStreetNumberMustBeANumber ].	streetNumber := streetNumber asInteger.	zipCode := record fifth.	(zipCode matchesRegex: '-?[0-9]+')		ifFalse: [ PartyImportError new signal: self class zipCodeMustBeANumber ].	zipCode := zipCode asInteger.	^ Address		street: record second		number: streetNumber		town: record fourth		zipCode: zipCode		province: record sixth! !!PartyImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 21:14'!readNextLine	| hasNextLine |	currentLine := inputStream nextLine.	hasNextLine := currentLine notNil.		hasNextLine ifTrue: [ currentLine := currentLine trim ].	^ hasNextLine! !!PartyImport methodsFor: 'initialization' stamp: 'DamianFurman 11/22/2017 20:59'!initializeInto: aSystem	system := aSystem.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PartyImport class	instanceVariableNames: ''!!PartyImport class methodsFor: 'instance creation' stamp: 'DamianFurman 11/9/2017 21:40'!into: aDatabase	^ super new initializeInto: aDatabase.! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 19:05'!addressMustHaveCustomer	^ 'Attempt to import address without a Customer'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 22:25'!addressStreetNumberMustBePositive	^ 'Street number for address must be a positive integer'.! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 22:49'!zipCodeMustBePositive	^ 'Zip code must be a positive number'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 18:59'!unknownRecordType	^ 'Record begins with invalid identifier'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 18:50'!addressRecordSizeError	^ 'Address record length should always be 6'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 20:58'!addressStreetNumberMustBeANumber	^ 'Address must have a positive integer as street number.'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 22:45'!zipCodeMustBeANumber	^ 'Zip code must be a number'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 18:47'!customerRecordSizeError	^ 'Customer record length should always be 5'.! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 15:33'!newCustomerAlreadyExists	^ 'Attempted to add a new customer for a supplier, but it already exists'! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 16:14'!customerAlreadyExists	^ 'Attempted to create a new customer, but it already exists'.! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 20:41'!existingCustomerRecordSizeError	^ 'Existing customer record must have exactly three fields'.! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 20:15'!supplierRecordSizeError	^ 'Supplier record must have exactly four fields'! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 19:46'!attemptToImportAlreadyExistingSupplier	^ 'Attempted to import already existing supplier'.! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 19:08'!existingCustomerMustHaveSupplier	^ 'Existing customer record must have a supplier'! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 19:22'!newCustomerMustHaveSupplier	^ 'New customer must have a supplier'! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 20:31'!customerDoesNotExist	^ 'Customer should exist but does not'.! !PartyImport subclass: #CustomerImport	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 20:58'!isCustomerRecord	^ record first = 'C'! !!CustomerImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 21:08'!parseRecord	self isCustomerRecord		ifTrue: [ newParty := self parseCustomer.			system				fetchCustomerByIdentification: newParty identification				ifNone: [ system addCustomer: newParty.					^ nil ].			PartyImportError new signal: self class customerAlreadyExists ].	self isAddressRecord		ifTrue: [ newParty addAddress: self parseAddress.			^ nil ].	PartyImportError new signal: self class unknownRecordType! !!CustomerImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 20:58'!readNextLine	| hasNextLine |	currentLine := inputStream nextLine.	hasNextLine := currentLine notNil.		hasNextLine ifTrue: [ currentLine := currentLine trim ].	^ hasNextLine! !!CustomerImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 20:58'!isAddressRecord	^ record first = 'A'! !Exception subclass: #PartyImportError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!ErpSystem subclass: #PersistentPartySystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PersistentPartySystem methodsFor: 'initialize-release' stamp: 'DamianFurman 11/23/2017 12:49'!initialize	session := DataBaseSession for: (Array with: self class addressMapping with: self class customerMapping with: self class supplierMapping)! !!PersistentPartySystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/13/2017 19:59'!close	session close.! !!PersistentPartySystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/13/2017 19:55'!start	session open.! !!PersistentPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 19:56'!beginTransaction	session beginTransaction ! !!PersistentPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/16/2017 19:29'!addCustomer: aCustomer	session persist: aCustomer! !!PersistentPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 19:58'!commit	session commit.! !!PersistentPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:18'!allSuppliers	^ session selectAllOfType: Supplier! !!PersistentPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:30'!addSupplier: aSupplier	session persist: aSupplier .! !!PersistentPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:29'!allCustomers	^ session selectAllOfType: Customer.! !!PersistentPartySystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/16/2017 19:25'!selectCustomers: aBlockClosure	^ session select: aBlockClosure ofType: Customer! !!PersistentPartySystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/16/2017 19:26'!selectSuppliers: aBlockClosure	^ session select: aBlockClosure ofType: Supplier.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PersistentPartySystem class	instanceVariableNames: ''!!PersistentPartySystem class methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 20:56'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentPartySystem class methodsFor: 'data' stamp: 'JulianBayardo 11/16/2017 19:12'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentPartySystem class methodsFor: 'data' stamp: 'DamianFurman 11/23/2017 12:48'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #name)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address)).! !Enviroment subclass: #ProductionEnviroment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ProductionEnviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:07'!createErpSystem	^ PersistentPartySystem new.! !!ProductionEnviroment methodsFor: 'testing' stamp: 'DamianFurman 11/23/2017 12:58'!isActive^ true! !Party subclass: #Supplier	instanceVariableNames: 'name customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Supplier methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:49'!customers	^ customers.! !!Supplier methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 20:46'!addCustomer: aCustomer 	customers add: aCustomer.! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/16/2017 20:51'!hash	^ super hash bitXor: (self name hash)! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/16/2017 19:18'!name	^ name.! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/16/2017 20:51'!= aSupplier	^ super = aSupplier and: (self name = aSupplier name)! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 18:50'!initializeName: aName identification: anIdentification	name := aName.	self initializeIdentification: anIdentification .! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 15:59'!initialize	super initialize.	customers := Set new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Supplier class	instanceVariableNames: ''!!Supplier class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 18:50'!name: aName identification: anIdentification	^ self new initializeName: aName identification: anIdentification! !PartyImport subclass: #SupplierImport	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SupplierImport methodsFor: 'testing' stamp: 'DamianFurman 11/22/2017 21:14'!isAddressRecord	^ record first = 'A'! !!SupplierImport methodsFor: 'parsing' stamp: 'DamianFurman 11/23/2017 11:28'!parseExistingCustomerIdentification	record size = 3		ifFalse: [ PartyImportError new signal: self class existingCustomerRecordSizeError ].	^ Identification number: record third type: record second! !!SupplierImport methodsFor: 'parsing' stamp: 'DamianFurman 11/22/2017 21:02'!parseSupplier	record size = 4		ifFalse: [ PartyImportError new signal: self class supplierRecordSizeError ].	^ Supplier name: record second identification: (Identification number: record fourth type: record third).! !!SupplierImport methodsFor: 'parsing' stamp: 'DamianFurman 11/22/2017 21:26'!parseRecord	self isAddressRecord		ifTrue: [ newParty addAddress: self parseAddress.			^ nil ].	self isSupplierRecord		ifTrue: [ newParty := self parseSupplier.			system				fetchSupplierByIdentification: newParty identification				ifNone: [ system addSupplier: newParty.					^ nil ].				PartyImportError new signal: super class attemptToImportAlreadyExistingSupplier. ].	self isExistingCustomerRecord		ifTrue: [ | identification customer |			(newParty isKindOf: Supplier)				ifFalse: [ PartyImportError new signal: super class existingCustomerMustHaveSupplier ].			identification := self parseExistingCustomerIdentification.			customer := system fetchCustomerByIdentification: identification ifNone: [ ^ PartyImportError new signal: self class customerDoesNotExist ].			newParty addCustomer: customer.			^ nil ].	self isNewCustomerRecord		ifTrue: [ | newCustomer |			(newParty isKindOf: Supplier)				ifFalse: [ PartyImportError new signal: super class newCustomerMustHaveSupplier ].			newCustomer := self parseCustomer.			system				fetchCustomerByIdentification: newCustomer identification				ifNone: [ system addCustomer: newCustomer.					newParty addCustomer: newCustomer.					^ nil ].			PartyImportError new signal: super class newCustomerAlreadyExists ].	PartyImportError new signal: self class unknownRecordType .! !!SupplierImport methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/22/2017 21:01'!isSupplierRecord	^ record first = 'S'.! !!SupplierImport methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/22/2017 21:01'!isExistingCustomerRecord	^ record first = 'EC'.! !!SupplierImport methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/22/2017 21:01'!isNewCustomerRecord	^ record first = 'NC'.! !ErpTest subclass: #SupplierImportTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:31'!test07importSupplierWithNewCustomer	| inputStream supplier customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		NC,Domingo,Sanchez,D,444444'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 3.	supplier := self supplierImported: self instanceSimpleSupplier.	customer := system fetchCustomerByIdentification: (Identification number: '444444' type: 'D') ifNone: [ self fail ].	self assert: (supplier customers includes: customer).	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:48'!test15importAlreadyExistingSupplierFails	| inputStream supplier |	inputStream := ReadStream		on:			'S,Supplier1,D,123		S,Supplier1,D,123'.	self		should: [ (SupplierImport into: system) import: inputStream ]		raise: PartyImportError		description: PartyImport attemptToImportAlreadyExistingSupplier.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 2.	supplier := self supplierImported: self instanceSimpleSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:31'!test08importSupplierWithAddress	| inputStream supplier address |	inputStream := ReadStream		on:			'S,Supplier1,D,123		A,San Martin,222222,Olivos,1636,BsAs'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 2.	supplier := self supplierImported: self instanceSimpleSupplier.	address := Address		street: 'San Martin'		number: 222222		town: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self assert: (supplier addresses includes: address).	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:27'!test03importSupplierWithExistingCustomerThatDoesNotExistShouldFail	| inputStream |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D,54R4K47UN64'.	self should: [ (SupplierImport into: system) import: inputStream. ] raise: PartyImportError description: PartyImport customerDoesNotExist.	self assert: system numberOfSuppliers equals: 1.	self supplierImported: self instanceSimpleSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:29'!test06importSupplierWithNewCustomerAlreadyExistingShoudFail	| inputStream supplier customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		NC,Pepe,Sanchez,D,22333444'.	customer := system fetchCustomerByIdentification: (Identification number: '22333444' type: 'D') ifNone: [ self fail ].	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport newCustomerAlreadyExists.	self assert: system numberOfSuppliers equals: 1.	supplier := self supplierImported: self instanceSimpleSupplier.	self assert: (supplier customers includes: customer) not.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:47'!test13importNewCustomerUsingSupplierImporterShoudBeRecordUnknown	| inputStream |	inputStream := ReadStream		on:			'C,Bondiola,Sanchez,D,66333444'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport unknownRecordType .	self assert: system numberOfSuppliers equals: 0.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:37'!test12importNewCustomerWithoutSupplierShouldFail	| inputStream |	inputStream := ReadStream		on:			'NC,Domingo,Sanchez,D,444444'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport newCustomerMustHaveSupplier.	self assert: system numberOfSuppliers equals: 0.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:28'!test04existingCustomerRecordMustHaveExactlyThreeFields	| inputStream |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport existingCustomerRecordSizeError.	self assert: system numberOfSuppliers equals: 1.	self supplierImported: self instanceSimpleSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:27'!test01supplierRecordMustHaveExactlyFourFields	| inputStream |	inputStream := ReadStream on: 'S,Supplier1,D'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport supplierRecordSizeError.	self assert: system hasNoSuppliers.	inputStream close.! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:27'!test02invalidSupplierIdentifierGeneratesError	| inputStream |	inputStream := ReadStream on: 'SARACATUNGA,Supplier1,D,123'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport unknownRecordType.	self assert: system hasNoSuppliers.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:37'!test11importExistingCustomerWithoutSupplierShouldFail	| inputStream |	inputStream := ReadStream on: 'EC,D,22333444'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport existingCustomerMustHaveSupplier.	self assert: system numberOfSuppliers equals: 0.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:10'!test00importSupplier	| inputStream |	inputStream := ReadStream on: 'S,Supplier1,D,123'.	(SupplierImport into: system) import: inputStream.	self supplierImported: self instanceSimpleSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:28'!test05importSupplierWithExistingCustomer	| inputStream supplier customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D,22333444'.	customer := system fetchCustomerByIdentification: (Identification number: '22333444' type: 'D') ifNone: [ self fail ].	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	supplier := self supplierImported: self instanceSimpleSupplier.	self assert: (supplier customers includes: customer).	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:31'!test09importSupplierWithNewCustomerAndAddress	| inputStream supplier address customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		NC,Domingo,Sanchez,D,444444		A,San Martin,222222,Olivos,1636,BsAs'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 3.	supplier := self supplierImported: self instanceSimpleSupplier.	customer := system		fetchCustomerByIdentification: (Identification number: '444444' type: 'D')		ifNone: [ self fail ].	address := Address		street: 'San Martin'		number: 222222		town: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self assert: (supplier addresses includes: address).	self assert: (customer addresses includes: address) not.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:36'!test10importSupplierWithExistingCustomerAndAddress	| inputStream supplier address customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D,22333444		A,San Martin,222222,Olivos,1636,BsAs'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 2.	supplier := self supplierImported: self instanceSimpleSupplier.	customer := system		fetchCustomerByIdentification: (Identification number: '22333444' type: 'D')		ifNone: [ self fail ].	address := Address		street: 'San Martin'		number: 222222		town: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self assert: (supplier addresses includes: address).	self assert: (customer addresses includes: address) not.	inputStream close! !!SupplierImportTest methodsFor: 'running' stamp: 'DamianFurman 11/23/2017 11:52'!setUp	super setUp.	(CustomerImport into: system) import: (self instanceCustomerDatabaseStream ).! !!SupplierImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/22/2017 18:52'!instanceSimpleSupplier	^ Supplier name: 'Supplier1' identification: (Identification number: '123' type: 'D').! !!SupplierImportTest methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:55'!supplierImported: anExpectedSupplier	| supplier |	supplier := system fetchSupplierByIdentification: anExpectedSupplier identification ifNone: [ self fail ].	self assert: supplier equals: anExpectedSupplier.	^ supplier! !Enviroment subclass: #TestEnviroment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TestEnviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:07'!createErpSystem	^ TransientPartySystem new! !!TestEnviroment methodsFor: 'testing' stamp: 'DamianFurman 11/23/2017 12:56'!isActive	^ false! !ErpSystem subclass: #TransientPartySystem	instanceVariableNames: 'customers suppliers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TransientPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 22:34'!beginTransaction! !!TransientPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/16/2017 19:34'!addCustomer: anObject	customers add: anObject! !!TransientPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/16/2017 19:39'!selectCustomers: aBlockClosure	^ customers select: aBlockClosure! !!TransientPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 22:34'!commit! !!TransientPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:18'!allSuppliers	^ suppliers! !!TransientPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:31'!addSupplier: aSupplier	suppliers add: aSupplier.! !!TransientPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:18'!allCustomers	^ customers! !!TransientPartySystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/16/2017 19:39'!selectSuppliers: aBlockClosure	^ suppliers select: aBlockClosure! !!TransientPartySystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/13/2017 22:34'!close	! !!TransientPartySystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/16/2017 19:31'!start	customers := OrderedCollection new.	suppliers := OrderedCollection new.! !