Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 21:15'!assertHasIdInstanceVariable: aClass 		(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!Mapping methodsFor: 'assertions' stamp: 'HernanWilkinson 11/1/2016 01:31'!assertIsValidFor: aClass 	(aClass hasInstVarNamed: instanceVariableName) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-PersistanceModel'!!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'accessing' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 18:58'!initializeStreet: aStreetName number: aStreetNumber town: aTownName province: aProvinceName zipCode: aZipCode	aStreetNumber > 0		ifFalse: [ PartyImportError new signal: PartyImport addressStreetNumberMustBePositive ].	aZipCode > 0		ifFalse: [ PartyImportError new signal: PartyImport zipCodeMustBePositive ].	streetName := aStreetName.	streetNumber := aStreetNumber.	town := aTownName.	province := aProvinceName.	zipCode := aZipCode! !!Address methodsFor: 'comparing' stamp: 'JulianBayardo 11/7/2017 00:00'!= anAddress	^ self streetName = anAddress streetName and: (self streetNumber = anAddress streetNumber and: (self town = anAddress town and: (self zipCode = anAddress zipCode and: (self province = anAddress province)))).! !!Address methodsFor: 'comparing' stamp: 'JulianBayardo 11/7/2017 00:08'!hash	^ self streetName hash		bitXor:			(self streetNumber hash bitXor: (self town hash bitXor: (self zipCode hash bitXor: self province hash)))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Address class	instanceVariableNames: ''!!Address class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 19:34'!street: aStreetName number: aStreetNumber town: aTownName zipCode: aZipCode province: aProvinceName	^ self new initializeStreet: aStreetName number: aStreetNumber town: aTownName province: aProvinceName zipCode: aZipCode! !Object subclass: #Enviroment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Enviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:07'!createErpSystem	self subclassResponsibility .! !!Enviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/13/2017 22:28'!isActive	^ false! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Enviroment class	instanceVariableNames: ''!!Enviroment class methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 18:02'!current	^ (self subclasses collect: [ :aClass | aClass new ])		detect: [ :anEnvironment | anEnvironment isActive ]		ifFound: [ :anEnvironment | ^ anEnvironment ]		ifNone: [ ^ TestEnviroment new ].! !Object subclass: #ErpSystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ErpSystem methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 20:03'!fetchSupplierByIdentification: anIdentification ifNone: aBlockClosure	| suppliers |	suppliers := self selectSuppliers: [ :aSupplier | aSupplier identification = anIdentification ].	suppliers isEmpty		ifTrue: [ ^ aBlockClosure value ].	^ suppliers at: 1! !!ErpSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/13/2017 22:32'!close	self subclassResponsibility 	! !!ErpSystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/13/2017 22:32'!start	self subclassResponsibility .! !!ErpSystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/16/2017 19:21'!selectCustomers: aBlockClosure	self subclassResponsibility .		! !!ErpSystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/16/2017 19:22'!selectSuppliers: aBlockClosure	self subclassResponsibility! !!ErpSystem methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:02'!fetchCustomerByIdentification: anIdentification ifNone: aBlock	| customers |	customers := self selectCustomers: [ :aCustomer | aCustomer identification = anIdentification ].	customers size = 0		ifTrue: [ ^ aBlock value ].	^ customers at: 1! !!ErpSystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 22:31'!beginTransaction	self subclassResponsibility! !!ErpSystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/16/2017 19:47'!addCustomer: aCustomer	self subclassResponsibility! !!ErpSystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 22:32'!commit	self subclassResponsibility ! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:17'!hasNoSuppliers	^ self numberOfSuppliers = 0! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:29'!allCustomers	self subclassResponsibility.! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:17'!numberOfSuppliers	^ self allSuppliers size! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:17'!allSuppliers	self subclassResponsibility .! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:48'!numberOfCustomers	^ self allCustomers size! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:48'!hasNoCustomers	^ self numberOfCustomers = 0.! !!ErpSystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:30'!addSupplier: aSupplier	self subclassResponsibility .! !TestCase subclass: #ErpTest	instanceVariableNames: 'system'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ErpTest methodsFor: 'data' stamp: 'JulianBayardo 11/16/2017 20:26'!instanceCustomerDatabaseStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!ErpTest methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:24'!customerImportedWithAddresses: anExpectedCustomer	| customer |	customer := self customerImported: anExpectedCustomer.	self assert: customer addresses equals: anExpectedCustomer addresses.	^ customer.! !!ErpTest methodsFor: 'testing' stamp: 'JulianBayardo 11/22/2017 15:37'!should: aBlock raise: anExceptionClass description: anExpectedDescription	^ self should: aBlock raise: anExceptionClass withExceptionDo: [ :anException | self assert: anException messageText equals: anExpectedDescription ]! !!ErpTest methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:24'!customerImported: anExpectedCustomer	| customer |	customer := system fetchCustomerByIdentification: anExpectedCustomer identification ifNone: [ self fail ].	self assert: customer equals: anExpectedCustomer.	^ customer! !!ErpTest methodsFor: 'running' stamp: 'JulianBayardo 11/16/2017 20:24'!setUp	system := Enviroment current createErpSystem.	system start.	system beginTransaction! !!ErpTest methodsFor: 'running' stamp: 'JulianBayardo 11/16/2017 20:24'!tearDown	system commit.	system close! !ErpTest subclass: #CustomerImportTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 22:49'!instanceZipCodeNegativeIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,2233,Olivos,-21,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 22:49'!instanceZipCodeNotAnIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,2233,Olivos,12ss,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 22:25'!instanceStreetNumberNegativeIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,-33,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:18'!instanceStreetNumberNotAnIntegerStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,2ll322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:17'!instanceUnknownAddressRecordTypeStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444AA,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:17'!instanceWhitespaceSeparatedStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444     C,Juan,Perez,C,23-25666777-9'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:16'!instanceIncompleteCustomerStream	^ ReadStream on: 'C,Pepe,Sanchez,D,'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:17'!instanceSingleAddressStream	^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:16'!instanceIncompleteAddressStream	^ ReadStream		on:			'C,Pepe,Sanchez,D,22333444A,San Martin,3322,Olivos,1636,'! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:15'!instanceEmptyStream	^ ReadStream on: ''! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/22/2017 19:34'!instanceJuanPerez	| customer |	customer := Customer		first: 'Juan'		last: 'Perez'		identification: (Identification number: '23-25666777-9' type: 'C').	customer		addAddress:			(Address				street: 'Alem'				number: 1122				town: 'CABA'				zipCode: 1001				province: 'CABA').	^ customer! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/22/2017 19:34'!instancePepeSanchez	| customer |	customer := Customer		first: 'Pepe'		last: 'Sanchez'		identification: (Identification number: '22333444' type: 'D').	customer		addAddress:			(Address				street: 'San Martin'				number: 3322				town: 'Olivos'				zipCode: 1636				province: 'BsAs').	customer		addAddress:			(Address				street: 'Maipu'				number: 888				town: 'Florida'				zipCode: 1122				province: 'Buenos Aires').	^ customer! !!CustomerImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 21:16'!instanceUnknownCustomerRecordTypeStream	^ ReadStream on: 'CC,Pepe,Sanchez,D,22333444'! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:05'!test02customerRecordMustHaveExactlyFiveFields	| inputStream |	inputStream := self instanceIncompleteCustomerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport customerRecordSizeError.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test10zipCodeIsANumber	| inputStream |	inputStream := self instanceZipCodeNotAnIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport zipCodeMustBeANumber.	self customerImported: self instancePepeSanchez.	self assert: system numberOfCustomers equals: 1.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:10'!test12multipleRunsDoNotKeepCustomer	| inputStream importer inputStream2 |	importer := CustomerImport into: system.	inputStream := self instanceCustomerDatabaseStream.	importer import: inputStream.	inputStream close.	inputStream2 := self instanceSingleAddressStream.	self should: [ importer import: inputStream2 ] raise: PartyImportError description: PartyImport addressMustHaveCustomer.	inputStream2 close.! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:04'!test01emptyStreamDoesNotImport	| inputStream |	inputStream := self instanceEmptyStream.	(CustomerImport into: system) import: inputStream.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:10'!test13addAlreadyExistingCustomerFails	| inputStream importer inputStream2 |	importer := CustomerImport into: system.	inputStream := self instanceCustomerDatabaseStream.	importer import: inputStream.	inputStream close.	inputStream2 := self instanceCustomerDatabaseStream.	self should: [ importer import: inputStream2 ] raise: PartyImportError description: PartyImport customerAlreadyExists.	inputStream2 close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test05invalidAddressIdentifierGeneratesError	| inputStream |	inputStream := self instanceUnknownAddressRecordTypeStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport unknownRecordType.	self customerImported: self instancePepeSanchez.	self assert: system numberOfCustomers equals: 1.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test08addressStreetNumberIsANumber	| inputStream |	inputStream := self instanceStreetNumberNotAnIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport addressStreetNumberMustBeANumber.	self customerImported: self instancePepeSanchez.	self assert: system numberOfCustomers equals: 1.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test11zipCodeIsPositive	| inputStream |	inputStream := self instanceZipCodeNegativeIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport zipCodeMustBePositive.	self customerImported: self instancePepeSanchez.		self assert: system numberOfCustomers equals: 1.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:05'!test04invalidCustomerIdentifierGeneratesError	| inputStream |	inputStream := self instanceUnknownCustomerRecordTypeStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport unknownRecordType.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test07whitespaceIsSkipped	| inputStream |	inputStream := self instanceWhitespaceSeparatedStream.	(CustomerImport into: system) import: inputStream.	self customerImported: self instancePepeSanchez.	self customerImported: self instanceJuanPerez.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test06addressMustHaveCustomer	| inputStream |	inputStream := self instanceSingleAddressStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport addressMustHaveCustomer.	self assert: system hasNoCustomers.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:04'!test00hasAllCustomers	| inputStream |	inputStream := self instanceCustomerDatabaseStream.	(CustomerImport into: system) import: inputStream.	self customerImportedWithAddresses: self instancePepeSanchez.	self customerImportedWithAddresses: self instanceJuanPerez.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:05'!test03addressRecordMustHaveExactlySixFields	| inputStream |	inputStream := self instanceIncompleteAddressStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport addressRecordSizeError.	self customerImported: self instancePepeSanchez.		self assert: system numberOfCustomers equals: 1.	inputStream close! !!CustomerImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:09'!test09addressStreetNumberIsPositive	| inputStream |	inputStream := self instanceStreetNumberNegativeIntegerStream.	self should: [ (CustomerImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport addressStreetNumberMustBePositive.	self customerImported: self instancePepeSanchez.	self assert: system numberOfCustomers equals: 1.	inputStream close! !Object subclass: #Identification	instanceVariableNames: 'identificationNumber identificationType'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Identification methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:51'!number	^ identificationNumber! !!Identification methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:51'!type	^ identificationType! !!Identification methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:52'!initializeNumber: anIdNumber type: anIdType	identificationNumber := anIdNumber .	identificationType := anIdType .! !!Identification methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 20:00'!= anIdentification	^ self type = anIdentification type and: self number = anIdentification number! !!Identification methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 19:59'!hash	^ self type hash bitXor: self number hash! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Identification class	instanceVariableNames: ''!!Identification class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 19:52'!number: anIdNumber type: anIdType	^ self new initializeNumber: anIdNumber type: anIdType.! !Object subclass: #Party	instanceVariableNames: 'addresses identificationNumber identificationType identification'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Party methodsFor: 'identification' stamp: 'JulianBayardo 11/16/2017 19:54'!identification	^ identification! !!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 20:51'!= aParty	^ self identification = aParty identification! !!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 20:47'!addresses	^ addresses! !!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 20:51'!hash	^ self identification hash! !!Party methodsFor: 'addresses' stamp: 'JulianBayardo 11/16/2017 19:34'!addAddress: anAddress 	addresses add: anAddress ! !!Party methodsFor: 'initialization' stamp: 'JulianBayardo 11/16/2017 20:47'!initialize	addresses := Set new! !!Party methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 18:43'!initializeIdentification: anIdentification	identification := anIdentification .! !Party subclass: #Customer	instanceVariableNames: 'firstName lastName'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Customer methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 18:44'!initializeFirst: aFirstName last: aLastName identification: anIdentification	firstName := aFirstName.	lastName := aLastName.	self initializeIdentification: anIdentification .! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'comparing' stamp: 'JulianBayardo 11/16/2017 19:42'!= aCustomer	^ (super = aCustomer and: (self firstName = aCustomer firstName and: self lastName = aCustomer lastName))! !!Customer methodsFor: 'comparing' stamp: 'JulianBayardo 11/16/2017 19:43'!hash	^ (super hash bitXor: (self firstName hash bitXor: self lastName hash))! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Customer class	instanceVariableNames: ''!!Customer class methodsFor: 'accessing' stamp: 'JulianBayardo 11/22/2017 18:46'!first: aFirstName last: aLastName identification: anIdentification	^ self new		initializeFirst: aFirstName		last: aLastName		identification: anIdentification.! !Object subclass: #PartyImport	instanceVariableNames: 'inputStream currentLine record system newParty'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PartyImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 20:59'!import: aStream	inputStream := aStream.	newParty := nil.	[ self readNextLine ]		whileTrue: [ currentLine isEmpty				ifFalse: [ self createRecordFromLine.					self parseRecord ] ]! !!PartyImport methodsFor: 'data' stamp: 'DamianFurman 11/23/2017 11:30'!parseCustomer	record size = 5		ifFalse: [ PartyImportError new signal: self class customerRecordSizeError ].	^ Customer		first: record second		last: record third		identification: (Identification number: record fifth type: record fourth).! !!PartyImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 20:59'!createRecordFromLine	record := currentLine substrings: {$,}.	^ record! !!PartyImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 21:01'!parseAddress	| streetNumber zipCode |	newParty isNil		ifTrue: [ PartyImportError new signal: self class addressMustHaveCustomer ].	record size = 6		ifFalse: [ PartyImportError new signal: self class addressRecordSizeError ].	streetNumber := record third.	" Esto se hace con regex porque asInteger parsea el primer digito que encuentra. "	(streetNumber matchesRegex: '-?[0-9]+')		ifFalse: [ PartyImportError new				signal: self class addressStreetNumberMustBeANumber ].	streetNumber := streetNumber asInteger.	zipCode := record fifth.	(zipCode matchesRegex: '-?[0-9]+')		ifFalse: [ PartyImportError new signal: self class zipCodeMustBeANumber ].	zipCode := zipCode asInteger.	^ Address		street: record second		number: streetNumber		town: record fourth		zipCode: zipCode		province: record sixth! !!PartyImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 21:14'!readNextLine	| hasNextLine |	currentLine := inputStream nextLine.	hasNextLine := currentLine notNil.		hasNextLine ifTrue: [ currentLine := currentLine trim ].	^ hasNextLine! !!PartyImport methodsFor: 'initialization' stamp: 'DamianFurman 11/22/2017 20:59'!initializeInto: aSystem	system := aSystem.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PartyImport class	instanceVariableNames: ''!!PartyImport class methodsFor: 'instance creation' stamp: 'DamianFurman 11/9/2017 21:40'!into: aDatabase	^ super new initializeInto: aDatabase.! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 19:05'!addressMustHaveCustomer	^ 'Attempt to import address without a Customer'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 22:25'!addressStreetNumberMustBePositive	^ 'Street number for address must be a positive integer'.! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 22:49'!zipCodeMustBePositive	^ 'Zip code must be a positive number'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 18:59'!unknownRecordType	^ 'Record begins with invalid identifier'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 18:50'!addressRecordSizeError	^ 'Address record length should always be 6'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 20:58'!addressStreetNumberMustBeANumber	^ 'Address must have a positive integer as street number.'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 22:45'!zipCodeMustBeANumber	^ 'Zip code must be a number'! !!PartyImport class methodsFor: 'errors' stamp: 'JulianBayardo 11/13/2017 18:47'!customerRecordSizeError	^ 'Customer record length should always be 5'.! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 15:33'!newCustomerAlreadyExists	^ 'Attempted to add a new customer for a supplier, but it already exists'! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 16:14'!customerAlreadyExists	^ 'Attempted to create a new customer, but it already exists'.! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 20:41'!existingCustomerRecordSizeError	^ 'Existing customer record must have exactly three fields'.! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 20:15'!supplierRecordSizeError	^ 'Supplier record must have exactly four fields'! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 19:46'!attemptToImportAlreadyExistingSupplier	^ 'Attempted to import already existing supplier'.! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 19:08'!existingCustomerMustHaveSupplier	^ 'Existing customer record must have a supplier'! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 19:22'!newCustomerMustHaveSupplier	^ 'New customer must have a supplier'! !!PartyImport class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 20:31'!customerDoesNotExist	^ 'Customer should exist but does not'.! !PartyImport subclass: #CustomerImport	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!CustomerImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 20:58'!isCustomerRecord	^ record first = 'C'! !!CustomerImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 21:08'!parseRecord	self isCustomerRecord		ifTrue: [ newParty := self parseCustomer.			system				fetchCustomerByIdentification: newParty identification				ifNone: [ system addCustomer: newParty.					^ nil ].			PartyImportError new signal: self class customerAlreadyExists ].	self isAddressRecord		ifTrue: [ newParty addAddress: self parseAddress.			^ nil ].	PartyImportError new signal: self class unknownRecordType! !!CustomerImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 20:58'!readNextLine	| hasNextLine |	currentLine := inputStream nextLine.	hasNextLine := currentLine notNil.		hasNextLine ifTrue: [ currentLine := currentLine trim ].	^ hasNextLine! !!CustomerImport methodsFor: 'data' stamp: 'DamianFurman 11/22/2017 20:58'!isAddressRecord	^ record first = 'A'! !Exception subclass: #PartyImportError	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!ErpSystem subclass: #PersistentPartySystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!PersistentPartySystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/13/2017 20:56'!initialize	session := DataBaseSession for: (Array with: self class addressMapping with: self class customerMapping)! !!PersistentPartySystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/13/2017 19:59'!close	session close.! !!PersistentPartySystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/13/2017 19:55'!start	session open.! !!PersistentPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 19:56'!beginTransaction	session beginTransaction ! !!PersistentPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/16/2017 19:29'!addCustomer: aCustomer	session persist: aCustomer! !!PersistentPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 19:58'!commit	session commit.! !!PersistentPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:18'!allSuppliers	^ session selectAllOfType: Supplier! !!PersistentPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:30'!addSupplier: aSupplier	session persist: aSupplier .! !!PersistentPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:29'!allCustomers	^ session selectAllOfType: Customer.! !!PersistentPartySystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/16/2017 19:25'!selectCustomers: aBlockClosure	^ session select: aBlockClosure ofType: Customer! !!PersistentPartySystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/16/2017 19:26'!selectSuppliers: aBlockClosure	^ session select: aBlockClosure ofType: Supplier.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!PersistentPartySystem class	instanceVariableNames: ''!!PersistentPartySystem class methodsFor: 'data' stamp: 'JulianBayardo 11/13/2017 20:56'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentPartySystem class methodsFor: 'data' stamp: 'JulianBayardo 11/16/2017 19:12'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !Enviroment subclass: #ProductionEnviroment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!ProductionEnviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:07'!createErpSystem	^ PersistentPartySystem new.! !Party subclass: #Supplier	instanceVariableNames: 'name customers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!Supplier methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:49'!customers	^ customers.! !!Supplier methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/16/2017 20:46'!addCustomer: aCustomer 	customers add: aCustomer.! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/16/2017 20:51'!hash	^ super hash bitXor: (self name hash)! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/16/2017 19:18'!name	^ name.! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/16/2017 20:51'!= aSupplier	^ super = aSupplier and: (self name = aSupplier name)! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 18:50'!initializeName: aName identification: anIdentification	name := aName.	self initializeIdentification: anIdentification .! !!Supplier methodsFor: 'initialization' stamp: 'JulianBayardo 11/22/2017 15:59'!initialize	super initialize.	customers := Set new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Supplier class	instanceVariableNames: ''!!Supplier class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/22/2017 18:50'!name: aName identification: anIdentification	^ self new initializeName: aName identification: anIdentification! !PartyImport subclass: #SupplierImport	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SupplierImport methodsFor: 'testing' stamp: 'DamianFurman 11/22/2017 21:14'!isAddressRecord	^ record first = 'A'! !!SupplierImport methodsFor: 'parsing' stamp: 'DamianFurman 11/23/2017 11:28'!parseExistingCustomerIdentification	record size = 3		ifFalse: [ PartyImportError new signal: self class existingCustomerRecordSizeError ].	^ Identification number: record third type: record second! !!SupplierImport methodsFor: 'parsing' stamp: 'DamianFurman 11/22/2017 21:02'!parseSupplier	record size = 4		ifFalse: [ PartyImportError new signal: self class supplierRecordSizeError ].	^ Supplier name: record second identification: (Identification number: record fourth type: record third).! !!SupplierImport methodsFor: 'parsing' stamp: 'DamianFurman 11/22/2017 21:26'!parseRecord	self isAddressRecord		ifTrue: [ newParty addAddress: self parseAddress.			^ nil ].	self isSupplierRecord		ifTrue: [ newParty := self parseSupplier.			system				fetchSupplierByIdentification: newParty identification				ifNone: [ system addSupplier: newParty.					^ nil ].				PartyImportError new signal: super class attemptToImportAlreadyExistingSupplier. ].	self isExistingCustomerRecord		ifTrue: [ | identification customer |			(newParty isKindOf: Supplier)				ifFalse: [ PartyImportError new signal: super class existingCustomerMustHaveSupplier ].			identification := self parseExistingCustomerIdentification.			customer := system fetchCustomerByIdentification: identification ifNone: [ ^ PartyImportError new signal: self class customerDoesNotExist ].			newParty addCustomer: customer.			^ nil ].	self isNewCustomerRecord		ifTrue: [ | newCustomer |			(newParty isKindOf: Supplier)				ifFalse: [ PartyImportError new signal: super class newCustomerMustHaveSupplier ].			newCustomer := self parseCustomer.			system				fetchCustomerByIdentification: newCustomer identification				ifNone: [ system addCustomer: newCustomer.					newParty addCustomer: newCustomer.					^ nil ].			PartyImportError new signal: super class newCustomerAlreadyExists ].	PartyImportError new signal: self class unknownRecordType .! !!SupplierImport methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/22/2017 21:01'!isSupplierRecord	^ record first = 'S'.! !!SupplierImport methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/22/2017 21:01'!isExistingCustomerRecord	^ record first = 'EC'.! !!SupplierImport methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/22/2017 21:01'!isNewCustomerRecord	^ record first = 'NC'.! !ErpTest subclass: #SupplierImportTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:31'!test07importSupplierWithNewCustomer	| inputStream supplier customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		NC,Domingo,Sanchez,D,444444'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 3.	supplier := self supplierImported: self instanceSimpleSupplier.	customer := system fetchCustomerByIdentification: (Identification number: '444444' type: 'D') ifNone: [ self fail ].	self assert: (supplier customers includes: customer).	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:48'!test15importAlreadyExistingSupplierFails	| inputStream supplier |	inputStream := ReadStream		on:			'S,Supplier1,D,123		S,Supplier1,D,123'.	self		should: [ (SupplierImport into: system) import: inputStream ]		raise: PartyImportError		description: PartyImport attemptToImportAlreadyExistingSupplier.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 2.	supplier := self supplierImported: self instanceSimpleSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:31'!test08importSupplierWithAddress	| inputStream supplier address |	inputStream := ReadStream		on:			'S,Supplier1,D,123		A,San Martin,222222,Olivos,1636,BsAs'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 2.	supplier := self supplierImported: self instanceSimpleSupplier.	address := Address		street: 'San Martin'		number: 222222		town: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self assert: (supplier addresses includes: address).	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:27'!test03importSupplierWithExistingCustomerThatDoesNotExistShouldFail	| inputStream |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D,54R4K47UN64'.	self should: [ (SupplierImport into: system) import: inputStream. ] raise: PartyImportError description: PartyImport customerDoesNotExist.	self assert: system numberOfSuppliers equals: 1.	self supplierImported: self instanceSimpleSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:29'!test06importSupplierWithNewCustomerAlreadyExistingShoudFail	| inputStream supplier customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		NC,Pepe,Sanchez,D,22333444'.	customer := system fetchCustomerByIdentification: (Identification number: '22333444' type: 'D') ifNone: [ self fail ].	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport newCustomerAlreadyExists.	self assert: system numberOfSuppliers equals: 1.	supplier := self supplierImported: self instanceSimpleSupplier.	self assert: (supplier customers includes: customer) not.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:47'!test13importNewCustomerUsingSupplierImporterShoudBeRecordUnknown	| inputStream |	inputStream := ReadStream		on:			'C,Bondiola,Sanchez,D,66333444'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport unknownRecordType .	self assert: system numberOfSuppliers equals: 0.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:37'!test12importNewCustomerWithoutSupplierShouldFail	| inputStream |	inputStream := ReadStream		on:			'NC,Domingo,Sanchez,D,444444'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport newCustomerMustHaveSupplier.	self assert: system numberOfSuppliers equals: 0.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:28'!test04existingCustomerRecordMustHaveExactlyThreeFields	| inputStream |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport existingCustomerRecordSizeError.	self assert: system numberOfSuppliers equals: 1.	self supplierImported: self instanceSimpleSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:27'!test01supplierRecordMustHaveExactlyFourFields	| inputStream |	inputStream := ReadStream on: 'S,Supplier1,D'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport supplierRecordSizeError.	self assert: system hasNoSuppliers.	inputStream close.! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:27'!test02invalidSupplierIdentifierGeneratesError	| inputStream |	inputStream := ReadStream on: 'SARACATUNGA,Supplier1,D,123'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport unknownRecordType.	self assert: system hasNoSuppliers.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:37'!test11importExistingCustomerWithoutSupplierShouldFail	| inputStream |	inputStream := ReadStream on: 'EC,D,22333444'.	self should: [ (SupplierImport into: system) import: inputStream ] raise: PartyImportError description: PartyImport existingCustomerMustHaveSupplier.	self assert: system numberOfSuppliers equals: 0.	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/22/2017 21:10'!test00importSupplier	| inputStream |	inputStream := ReadStream on: 'S,Supplier1,D,123'.	(SupplierImport into: system) import: inputStream.	self supplierImported: self instanceSimpleSupplier.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:28'!test05importSupplierWithExistingCustomer	| inputStream supplier customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D,22333444'.	customer := system fetchCustomerByIdentification: (Identification number: '22333444' type: 'D') ifNone: [ self fail ].	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	supplier := self supplierImported: self instanceSimpleSupplier.	self assert: (supplier customers includes: customer).	self assert: system numberOfCustomers equals: 2.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:31'!test09importSupplierWithNewCustomerAndAddress	| inputStream supplier address customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		NC,Domingo,Sanchez,D,444444		A,San Martin,222222,Olivos,1636,BsAs'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 3.	supplier := self supplierImported: self instanceSimpleSupplier.	customer := system		fetchCustomerByIdentification: (Identification number: '444444' type: 'D')		ifNone: [ self fail ].	address := Address		street: 'San Martin'		number: 222222		town: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self assert: (supplier addresses includes: address).	self assert: (customer addresses includes: address) not.	inputStream close! !!SupplierImportTest methodsFor: 'tests' stamp: 'DamianFurman 11/23/2017 11:36'!test10importSupplierWithExistingCustomerAndAddress	| inputStream supplier address customer |	inputStream := ReadStream		on:			'S,Supplier1,D,123		EC,D,22333444		A,San Martin,222222,Olivos,1636,BsAs'.	(SupplierImport into: system) import: inputStream.	self assert: system numberOfSuppliers equals: 1.	self assert: system numberOfCustomers equals: 2.	supplier := self supplierImported: self instanceSimpleSupplier.	customer := system		fetchCustomerByIdentification: (Identification number: '22333444' type: 'D')		ifNone: [ self fail ].	address := Address		street: 'San Martin'		number: 222222		town: 'Olivos'		zipCode: 1636		province: 'BsAs'.	self assert: (supplier addresses includes: address).	self assert: (customer addresses includes: address) not.	inputStream close! !!SupplierImportTest methodsFor: 'running' stamp: 'DamianFurman 11/23/2017 11:27'!setUp	super setUp.	(CustomerImport into: system) import: (self instanceCustomerDatabaseStream ).! !!SupplierImportTest methodsFor: 'data' stamp: 'JulianBayardo 11/22/2017 18:52'!instanceSimpleSupplier	^ Supplier name: 'Supplier1' identification: (Identification number: '123' type: 'D').! !!SupplierImportTest methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:55'!supplierImported: anExpectedSupplier	| supplier |	supplier := system fetchSupplierByIdentification: anExpectedSupplier identification ifNone: [ self fail ].	self assert: supplier equals: anExpectedSupplier.	^ supplier! !Enviroment subclass: #TestEnviroment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TestEnviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/16/2017 20:07'!createErpSystem	^ TransientPartySystem new! !!TestEnviroment methodsFor: 'testing' stamp: 'JulianBayardo 11/13/2017 22:28'!isActive	^ true! !ErpSystem subclass: #TransientPartySystem	instanceVariableNames: 'customers suppliers'	classVariableNames: ''	poolDictionaries: ''	category: '10Pines-C17-1-Model'!!TransientPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 22:34'!beginTransaction! !!TransientPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/16/2017 19:34'!addCustomer: anObject	customers add: anObject! !!TransientPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/16/2017 19:39'!selectCustomers: aBlockClosure	^ customers select: aBlockClosure! !!TransientPartySystem methodsFor: 'transaction' stamp: 'JulianBayardo 11/13/2017 22:34'!commit! !!TransientPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:18'!allSuppliers	^ suppliers! !!TransientPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 19:31'!addSupplier: aSupplier	suppliers add: aSupplier.! !!TransientPartySystem methodsFor: 'accessing' stamp: 'JulianBayardo 11/16/2017 20:18'!allCustomers	^ customers! !!TransientPartySystem methodsFor: 'enumerating' stamp: 'JulianBayardo 11/16/2017 19:39'!selectSuppliers: aBlockClosure	^ suppliers select: aBlockClosure! !!TransientPartySystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/13/2017 22:34'!close	! !!TransientPartySystem methodsFor: 'initialize-release' stamp: 'JulianBayardo 11/16/2017 19:31'!start	customers := OrderedCollection new.	suppliers := OrderedCollection new.! !'From Pharo6.0 of 13 May 2016 [Latest update: #60510] on 23 November 2017 at 11:49:23.345877 am'!!String methodsFor: '*10Pines-C17-1' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60510] on 23 November 2017 at 11:49:23.34629 am'!!Object methodsFor: '*10Pines-C17-1' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !