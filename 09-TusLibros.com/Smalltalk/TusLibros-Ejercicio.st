Exception subclass: #AmountInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #Book	instanceVariableNames: 'titulo autor isbn'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Book methodsFor: 'accessing' stamp: 'LosPibes 10/26/2017 18:48'!title	^ titulo! !!Book methodsFor: 'accessing' stamp: 'LosPibes 10/26/2017 18:57'!hash	^ self isbn hash.! !!Book methodsFor: 'accessing' stamp: 'LosPibes 10/26/2017 18:45'!isbn	^ isbn! !!Book methodsFor: 'accessing' stamp: 'LosPibes 10/26/2017 18:57'!= aBook	^ self isbn = aBook isbn.! !!Book methodsFor: 'accessing' stamp: 'LosPibes 10/26/2017 18:47'!author	^ autor! !!Book methodsFor: 'initialization' stamp: 'LosPibes 10/26/2017 18:48'!isbn: ISBN title: aTitle author: anAuthor	isbn := ISBN.	titulo := aTitle.	autor := anAuthor.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Book class	instanceVariableNames: ''!!Book class methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/26/2017 18:48'!isbn: ISBN title: titulo author: autor	^ Book new		isbn: ISBN		title: titulo		author: autor.! !TestCase subclass: #BookTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!BookTests methodsFor: 'tests' stamp: 'LosPibes 10/30/2017 20:28'!test01equalsUsingISBN	| book book2 |	book := Book isbn: 01 title: 'Test' author: 'Pirulo'.	book2 := Book isbn: 01 title: 'Test' author: 'Pirulo'.	self assert: book equals: book2.	self assert: (book hash) equals: (book2 hash).! !Object subclass: #Cart	instanceVariableNames: 'catalogue items'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Cart methodsFor: 'adding' stamp: 'LosPibes 10/30/2017 20:29'!add: anItem	^ self add: anItem amount: 1.! !!Cart methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 17:19'!add: anItem amount: anAmount	(catalogue includes: anItem)		ifFalse: [ ^ ItemUnknownException new signal ].	(anAmount isKindOf: Integer)		ifFalse: [ ^ AmountInvalidException new signal ].	anAmount > 0		ifFalse: [ ^ AmountInvalidException new signal ].	items add: anItem withOccurrences: anAmount.	^ self! !!Cart methodsFor: 'initialization' stamp: 'LosPibes 10/30/2017 20:30'!initialize	items := Bag new! !!Cart methodsFor: 'initialization' stamp: 'LosPibes 10/26/2017 20:51'!initializeCatalogue: aCatalogue 	catalogue := aCatalogue.! !!Cart methodsFor: 'accessing' stamp: 'JulianBayardo 10/31/2017 17:35'!isEmpty	^ items isEmpty.! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:30'!size	^ items size! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:30'!list	| aList |	aList := Set new.	items		doWithOccurrences: [ :anItem :occurrences | aList add: (Association key: anItem value: occurrences) ].	^ aList! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:31'!amount: anItem	^ items occurrencesOf: anItem! !!Cart methodsFor: 'accessing' stamp: 'JulianBayardo 11/2/2017 17:37'!price	^ catalogue priceCart: self list! !!Cart methodsFor: 'purchase' stamp: 'JulianBayardo 10/31/2017 15:59'!purchaseRemoveFromStock	^ catalogue doPurchase: (self list)! !!Cart methodsFor: 'purchase' stamp: 'JulianBayardo 10/31/2017 15:59'!purchaseCheckEnoughStock	^ catalogue canPurchase: (self list).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cart class	instanceVariableNames: ''!!Cart class methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/26/2017 20:59'!withCatalogue: aCatalogue	^ super new initializeCatalogue: aCatalogue! !Exception subclass: #CartEmptyException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!TestCase subclass: #CartTests	instanceVariableNames: 'defaultCart'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:01'!test05listOfItemsOfEmptyCartIsEmpty	self assert: defaultCart list size equals: 0! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:33'!test13priceSingle	defaultCart add: 1.	self assert: defaultCart price equals: 10! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test03canHoldMultipleItems	| book book2 |	book := 1.	book2 := 2.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: (defaultCart amount: book2) equals: 0.	defaultCart add: book2.	self assert: (defaultCart amount: book2) equals: 1.	self assert: defaultCart size equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test11amountsMustBeGreaterThanZero	| book |	book := 231.	self should: [ defaultCart add: book amount: 0 ] raise: AmountInvalidException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test01itemIsPresentAfterAdding	| book |	book := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: defaultCart size equals: 1.! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test02itemCanBeAddedMultipleTimes	| book |	book := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book amount: 2.	self assert: (defaultCart amount: book) equals: 2.	self assert: defaultCart size equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:34'!test16priceTwoMultipleUnits	defaultCart add: 1.	defaultCart add: 1.	defaultCart add: 231.	defaultCart add: 231.	self assert: defaultCart price equals: 66! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test10amountsMustBeIntegers	| book |	book := 231.	self should: [ defaultCart add: book amount: 1 / 3 ] raise: AmountInvalidException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:01'!test08ListOfMultipleItemsHasAccurateCounts	| book list computedList book2 |	book := 231.	defaultCart add: book amount: 2.	book2 := 321.	defaultCart add: book2.	list := Set new.	list add: (Association key: 231 value: 2).	list add: (Association key: 321 value: 1).	computedList := defaultCart list.	self assert: computedList size equals: 2.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:33'!test14priceTwo	defaultCart add: 1.	defaultCart add: 2.	self assert: defaultCart price equals: 23! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:33'!test12priceEmpty	self assert: defaultCart price equals: 0! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test09itemMustBeInCatalogue	| book catalogue book2 cart |	book := 2312.	book2 := 23111.	catalogue := Set new.	catalogue add: book.	cart := Cart withCatalogue: catalogue.	self should: [ cart add: book2 ] raise: ItemUnknownException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:01'!test06ListOfSingleItemHasAccurateCounts	| book list computedList |	book := 231.	defaultCart add: book.	list := Set new.	list add: (Association key: 231 value: 1).	computedList := defaultCart list.	self assert: computedList size equals: 1.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:01'!test07ListOfSingleItemTwiceHasAccurateCounts	| book list computedList |	book := 231.	defaultCart add: book amount: 2.	list := Set new.	list add: (Association key: 231 value: 2).	computedList := defaultCart list.	self assert: computedList size equals: 1.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:27'!test00newCarIsEmpty	self assert: defaultCart isEmpty! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:26'!instanceDefaultCatalogue	| catalogue |	catalogue := PriceTable new.	catalogue add: 1 price: 10 stock: 20.	catalogue add: 2 price: 13 stock: 2.	catalogue add: 231 price: 23 stock: 4.	catalogue add: 321 price: 433 stock: 4.	catalogue add: 444 price: 111 stock: 0.	^ catalogue! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:33'!test15priceSingleMultipleUnits	defaultCart add: 1.	defaultCart add: 1.	self assert: defaultCart price equals: 20! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:29'!test04canSearchByBookAlias	| book book2 |	book := 1.	book2 := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: (defaultCart amount: book2) equals: 1.	defaultCart add: book2.	self assert: (defaultCart amount: book) equals: 2.	self assert: (defaultCart amount: book2) equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:27'!setUp	defaultCart := Cart withCatalogue: self instanceDefaultCatalogue.! !Object subclass: #Cashier	instanceVariableNames: 'paymentProcessor salesBook'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Cashier methodsFor: 'initialization' stamp: 'JulianBayardo 11/1/2017 17:13'!processor: aPaymentProcessor salesBook: aSalesBook	paymentProcessor := aPaymentProcessor .	salesBook := aSalesBook.! !!Cashier methodsFor: 'validation' stamp: 'JulianBayardo 11/1/2017 15:58'!validateCard: aCard currentMonthOfYear: aMonthOfYear	(aCard hasExpired: aMonthOfYear)		ifTrue: [ CreditCardExpiredException new signal ].! !!Cashier methodsFor: 'validation' stamp: 'JulianBayardo 11/1/2017 17:19'!validateCart: aCart	aCart isEmpty		ifTrue: [ CartEmptyException new signal ].	aCart purchaseCheckEnoughStock ifFalse: [ OutOfStockException new signal. ].! !!Cashier methodsFor: 'purchase' stamp: 'JulianBayardo 11/1/2017 17:14'!checkout: aCart for: aCard currentDate: aTimestamp	| price transaction |	self validateCart: aCart.	self validateCard: aCard currentMonthOfYear: aTimestamp monthOfYear.	price := aCart price.	paymentProcessor debit: price into: aCard.	transaction := Transaction cart: aCart price: price card: aCard.	salesBook add: transaction.	aCart purchaseRemoveFromStock.	^ transaction! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cashier class	instanceVariableNames: ''!!Cashier class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/1/2017 17:13'!processor: aPaymentProcessor salesBook: aSalesBook	^ Cashier new processor: aPaymentProcessor salesBook: aSalesBook.! !TestCase subclass: #CashierTests	instanceVariableNames: 'paymentProcessor salesBook defaultCatalogue defaultCart cashier'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:17'!test08checkoutWithStolenCardFails	| currentDate card |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	paymentProcessor add: card.	paymentProcessor stolen: card.	self		should: [ cashier				checkout: defaultCart				for: card				currentDate: currentDate ]		raise: CreditCardStolenException.	self assert: paymentProcessor interactions equals: 1.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:15'!test04checkoutAddsToSaleBookAndUpdatesStock	| currentDate transaction card |	defaultCart add: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	paymentProcessor add: card funds: 2000.	transaction := cashier		checkout: defaultCart		for: card		currentDate: currentDate.	self assert: transaction cart equals: defaultCart.	self assert: transaction price equals: defaultCart price.	self assert: transaction card equals: card.	self assert: paymentProcessor interactions equals: 1.	self assert: (paymentProcessor balance: card) equals: 2000 - transaction price.	self assert: salesBook first equals: transaction.	self assert: salesBook size equals: 1.	self assert: (self instanceDefaultCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 1! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:15'!test05checkoutMultipleAddsToSaleBookAndUpdatesStock	| currentDate transaction card originalCatalogue |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	paymentProcessor add: card funds: 2000.	transaction := cashier		checkout: defaultCart		for: card		currentDate: currentDate.	self assert: transaction cart equals: defaultCart.	self assert: transaction price equals: defaultCart price.	self assert: transaction card equals: card.	self assert: paymentProcessor interactions equals: 1.	self assert: (paymentProcessor balance: card) equals: 2000 - transaction price.	self assert: salesBook first equals: transaction.	self assert: salesBook size equals: 1.	originalCatalogue := self instanceDefaultCatalogue.	self assert: (originalCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 5.	self assert: (originalCatalogue stock: 2) equals: (defaultCatalogue stock: 2) + 1! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/2/2017 17:34'!test06checkoutManyAddsToSalesBookAndUpdatesAppropriately	| currentDate transaction1 card originalCatalogue anotherCart transaction2 |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	anotherCart := Cart withCatalogue: defaultCatalogue.	anotherCart add: 1 amount: 6.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	paymentProcessor add: card funds: 2000.	transaction1 := cashier checkout: defaultCart for: card currentDate: currentDate.	transaction2 := cashier checkout: anotherCart for: card currentDate: currentDate.	self assert: (paymentProcessor balance: card) equals: 2000 - (transaction1 price + transaction2 price).	self assert: salesBook first equals: transaction1.	self assert: salesBook second equals: transaction2.	self assert: salesBook size equals: 2.	originalCatalogue := self instanceDefaultCatalogue.	self assert: (originalCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 11.	self assert: (originalCatalogue stock: 2) equals: (defaultCatalogue stock: 2) + 1! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:14'!test02checkoutNotEnoughStock	defaultCart add: 444.	self		should: [ cashier				checkout: defaultCart				for: nil				currentDate: nil ]		raise: OutOfStockException.	self assert: paymentProcessor interactions equals: 0.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:12'!setUp	paymentProcessor := MerchantProcessorMock new.	salesBook := OrderedCollection new.	defaultCatalogue := self instanceDefaultCatalogue.	defaultCart := Cart withCatalogue: defaultCatalogue.	cashier := Cashier processor: paymentProcessor salesBook: salesBook! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:15'!test03checkoutExpiredCard	| currentDate |	defaultCart add: 1.	currentDate := January first , 2004.	self		should: [ cashier				checkout: defaultCart				for: (self instanceExpiredCreditCard: currentDate)				currentDate: currentDate ]		raise: CreditCardExpiredException.	self assert: paymentProcessor interactions equals: 0.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:16'!test07checkoutWithFakeCardFails	| currentDate card |	defaultCart add: 1 amount: 5.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	self should: [ cashier checkout: defaultCart for: card currentDate: currentDate ] raise: CreditCardUnknownException.	self assert: paymentProcessor interactions equals: 1.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/2/2017 17:25'!test09checkoutNotEnoughFundsFails	| currentDate card |	defaultCart add: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	paymentProcessor add: card funds: 9.	self should: [ cashier checkout: defaultCart for: card currentDate: currentDate ] raise: CreditCardNotEnoughFundsException.	self assert: paymentProcessor interactions equals: 1.	self assert: (paymentProcessor balance: card) equals: 9.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test01checkoutEmpty	self		should: [ cashier				checkout: defaultCart				for: nil				currentDate: nil ]		raise: CartEmptyException.	self assert: paymentProcessor interactions equals: 0.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !!CashierTests methodsFor: 'data' stamp: 'JulianBayardo 10/31/2017 16:26'!instanceDefaultCatalogue	| catalogue |	catalogue := PriceTable new.	catalogue add: 1 price: 10 stock: 20.	catalogue add: 2 price: 13 stock: 2.	catalogue add: 231 price: 23 stock: 4.	catalogue add: 321 price: 433 stock: 4.	catalogue add: 444 price: 111 stock: 0.	^ catalogue! !!CashierTests methodsFor: 'data' stamp: 'LosPibes 10/30/2017 21:05'!instanceExpiredCreditCard: currentDate	^ CreditCard		owner: 'Roberto Bolanos'		number: 1234567891234567		expiration: (currentDate previous: (TimeUnits month with: 1)) monthOfYear! !!CashierTests methodsFor: 'data' stamp: 'LosPibes 10/30/2017 21:20'!instanceNonExpiredCreditCard: currentDate	^ CreditCard		owner: 'Roberto Bolanos'		number: 1234567891234567		expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear! !Object subclass: #CreditCard	instanceVariableNames: 'name number expiration'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CreditCard methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 20:53'!owner: aName number: aNumber expiration: aDate 	name := aName.	number := aNumber.	expiration := aDate.! !!CreditCard methodsFor: '*Aconcagua-Extensions' stamp: 'LosPibes 10/30/2017 21:03'!hasExpired: aMonthOfYear	^ self expiration < aMonthOfYear.! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:15'!expiration	^ expiration! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:15'!number	^ number.! !!CreditCard methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:05'!hash	^ number hash! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:14'!owner	^ name! !!CreditCard methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:05'!= aCreditCard	^ number = aCreditCard number! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CreditCard class	instanceVariableNames: ''!!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 20:53'!owner: aName number: aNumber expiration: aDate 	^ super new owner: aName number: aNumber expiration: aDate.! !Exception subclass: #CreditCardExpiredException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardNotEnoughFundsException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardNumberInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardOwnerNameInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardStolenException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardUnknownException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #InvalidUserException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #ItemUnknownException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #MerchantProcessor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!MerchantProcessor methodsFor: 'accessing' stamp: 'JulianBayardo 10/31/2017 17:29'!debit: anAmount into: aCard	^ self subclassResponsibility ! !MerchantProcessor subclass: #MerchantProcessorMock	instanceVariableNames: 'interactions stolen cards'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!MerchantProcessorMock methodsFor: 'testing' stamp: 'JulianBayardo 11/1/2017 16:44'!add: aCard	self add: aCard funds: 0.! !!MerchantProcessorMock methodsFor: 'testing' stamp: 'JulianBayardo 11/1/2017 16:28'!stolen: aCard	(cards includesKey: aCard) ifFalse: [ CreditCardUnknownException new signal ].	stolen add: aCard! !!MerchantProcessorMock methodsFor: 'testing' stamp: 'JulianBayardo 11/1/2017 16:37'!balance: aCard	^ [ cards at: aCard ] on: KeyNotFound do: [ CreditCardUnknownException new signal ]! !!MerchantProcessorMock methodsFor: 'testing' stamp: 'JulianBayardo 11/2/2017 17:33'!add: aCard funds: anAmount	cards		at: aCard		ifPresent: [ :currentBalance | 			| newBalance |			newBalance := currentBalance + anAmount.			newBalance < 0				ifTrue: [ CreditCardNotEnoughFundsException new signal ].			cards at: aCard put: newBalance ]		ifAbsent: [ anAmount < 0				ifTrue: [ AmountInvalidException new signal ].			cards at: aCard put: anAmount ]! !!MerchantProcessorMock methodsFor: 'testing' stamp: 'JulianBayardo 10/31/2017 17:22'!interactions	^ interactions! !!MerchantProcessorMock methodsFor: 'purchase' stamp: 'JulianBayardo 11/2/2017 17:30'!debit: anAmount into: aCard	interactions := interactions + 1.	(cards includesKey: aCard)		ifFalse: [ CreditCardUnknownException new signal ].	(stolen includes: aCard)		ifTrue: [ CreditCardStolenException new signal ].	self add: aCard funds: (anAmount negated).! !!MerchantProcessorMock methodsFor: 'initialization' stamp: 'JulianBayardo 11/1/2017 16:24'!initialize	interactions := 0.	cards := Dictionary new.	stolen := Set new! !TestCase subclass: #MerchantProcessorMockTests	instanceVariableNames: 'defaultMock'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!MerchantProcessorMockTests methodsFor: 'tests' stamp: 'JulianBayardo 11/2/2017 17:50'!test07cannotDebitIntoNegativeFunds	defaultMock add: 1 funds: 20.	self should: [ defaultMock add: 1 funds: -50 ] raise: CreditCardNotEnoughFundsException.	self assert: (defaultMock balance: 1) equals: 20.! !!MerchantProcessorMockTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:51'!test05debitAdjustsBalanceAccordingly	defaultMock add: 1 funds: 20.	self assert: defaultMock interactions equals: 0.	defaultMock debit: 12 into: 1.	self assert: defaultMock interactions equals: 1.	self assert: (defaultMock balance: 1) equals: 8.	defaultMock debit: -8 into: 1.	self assert: (defaultMock balance: 1) equals: 16.! !!MerchantProcessorMockTests methodsFor: 'tests' stamp: 'JulianBayardo 11/2/2017 17:50'!test06cardMustHaveFundsInitially	self should: [ defaultMock add: 1 funds: -8 ] raise: AmountInvalidException.	self should: [ defaultMock balance: 1 ] raise: CreditCardUnknownException .! !!MerchantProcessorMockTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:46'!test03debitToUnknownCardIsReported	self assert: defaultMock interactions equals: 0.	self		should: [ defaultMock debit: 12 into: 1 ]		raise: CreditCardUnknownException. self		assert: defaultMock interactions		equals: 1! !!MerchantProcessorMockTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:44'!test01addCard	self should: [ defaultMock balance: 0 ] raise: CreditCardUnknownException.	defaultMock add: 0 funds: 10.	self assert: (defaultMock balance: 0) equals: 10! !!MerchantProcessorMockTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:44'!test02addBalance	defaultMock add: 0 funds: 10.	self assert: (defaultMock balance: 0) equals: 10.	defaultMock add: 0 funds: 10.	self assert: (defaultMock balance: 0 ) equals: 20.! !!MerchantProcessorMockTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:14'!setUp	defaultMock := MerchantProcessorMock new! !!MerchantProcessorMockTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:46'!test04debitToStolenCardIsReported	defaultMock add: 1.	defaultMock stolen: 1.	self assert: defaultMock interactions equals: 0.	self should: [ defaultMock debit: 12 into: 1 ] raise: CreditCardStolenException.	self assert: defaultMock interactions equals: 1! !MerchantProcessor subclass: #MerchantProcessorREST	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!MerchantProcessorREST methodsFor: 'accessing' stamp: 'JulianBayardo 11/2/2017 17:44'!debit: anAmount into: aCard	" aCard es un objeto CreditCard"	| owner number expiration |	owner := self formatOwner: aCard.	number := self formatNumber: aCard.	expiration := self formatExpiration: aCard.! !Exception subclass: #OutOfStockException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #PriceInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #PriceTable	instanceVariableNames: 'prices stock'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!PriceTable methodsFor: 'purchase' stamp: 'JulianBayardo 11/1/2017 16:02'!canPurchase: aCollectionOfPurchases	^ aCollectionOfPurchases		noneSatisfy: [ :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			(self stock: item) < amount ]! !!PriceTable methodsFor: 'purchase' stamp: 'JulianBayardo 11/1/2017 16:02'!doPurchase: aCollectionOfPurchases 	aCollectionOfPurchases		do: [ :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			amount timesRepeat: [ stock remove: item ifAbsent: [ ] ]].! !!PriceTable methodsFor: 'initialization' stamp: 'LosPibes 10/30/2017 17:27'!initialize	stock := Bag new.	prices := Dictionary new.! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 16:03'!includes: anItem	^ stock includes: anItem! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:19'!price: anItem		^ [ prices at: anItem ] on: KeyNotFound do: [ ItemUnknownException new signal. ]! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:19'!stock: anItem	(self includes: anItem) ifFalse: [ ItemUnknownException new signal ].	^ stock occurrencesOf: anItem! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/2/2017 17:37'!priceCart: aCollectionOfPurchases	^ aCollectionOfPurchases 		inject: 0		into: [ :anAccumulatedPrice :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			anAccumulatedPrice + ((self price: item) * amount) ]! !!PriceTable methodsFor: 'testing' stamp: 'LosPibes 10/30/2017 19:47'!stock	^ stock! !!PriceTable methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 17:19'!add: anItem price: aPrice stock: anAmount	aPrice > 0		ifFalse: [ ^ PriceInvalidException new signal ].	(anAmount isKindOf: Integer)		ifFalse: [ ^ AmountInvalidException new signal ].	anAmount >= 0		ifFalse: [ ^ AmountInvalidException new signal ].	stock add: anItem withOccurrences: anAmount.	prices add: (Association key: anItem value: aPrice)! !!PriceTable methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 16:03'!add: anItem price: aPrice	^ self add: anItem price: aPrice stock: 0! !TestCase subclass: #PriceTableTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:04'!test02singlePrice	| table |	table := PriceTable new.	table add: 2 price: 5 stock: 0.	self assert: (table includes: 2) equals: true.	self assert: (table price: 2) equals: 5.	self assert: (table stock: 2) equals: 0.		self assert: (table includes: 5) equals: false.! !!PriceTableTests methodsFor: 'tests' stamp: 'DamianFurman 11/2/2017 20:37'!test01InvalidUserRaiseException	| table |	table := PriceTable new.	self assert: (table includes: 2) equals: false.	self should: [ table price: 2 ] raise: ItemUnknownException.	self should: [ table stock: 2 ] raise: ItemUnknownException! !Object subclass: #RESTInterface	instanceVariableNames: 'users catalog'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/2/2017 21:23'!createCartFor: aUser withPass: aPass	| pass |	pass := users at: aUser ifAbsent: [InvalidUserException new signal.] .	(pass = aPass) ifFalse: [ InvalidUserException new signal. ] .	^ 1	"^ (Cart withCatalogue: catalog)"! !!RESTInterface methodsFor: 'initialization' stamp: 'DamianFurman 11/2/2017 21:20'!initializeWithUsers: aDictionary andCatalog: aCatalog	users := aDictionary .	catalog := aCatalog .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RESTInterface class	instanceVariableNames: ''!!RESTInterface class methodsFor: 'initialization' stamp: 'DamianFurman 11/2/2017 21:19'!initializeWithUsers: aDictionary andCatalog: aCatalog	^ self new initializeWithUsers: aDictionary andCatalog: aCatalog .! !TestCase subclass: #RESTInterfaceTests	instanceVariableNames: 'restInterface'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/2/2017 21:09'!test03ValidUserReturnCartId	| cartId |	cartId := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	self assert: (cartId > 0).	! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/2/2017 21:09'!test02ValidUserInvalidPassRaiseException	self should: [ restInterface createCartFor: 'ValidUser' withPass: '123456' ] raise: InvalidUserException .	! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/2/2017 20:43'!test01InvalidUserRaiseException	self should: [ restInterface createCartFor: 'Pepe' withPass: '123456' ] raise: InvalidUserException .! !!RESTInterfaceTests methodsFor: 'initialization' stamp: 'DamianFurman 11/2/2017 21:21'!setUp	| init |	init := Dictionary new .	init at: 'ValidUser' put: 'ValidPass' .	restInterface := RESTInterface initializeWithUsers: init andCatalog: PriceTable new .! !Object subclass: #Transaction	instanceVariableNames: 'cart price card timestamp'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Transaction methodsFor: 'initialization' stamp: 'JulianBayardo 10/31/2017 15:42'!initializeCart: aCart price: aPrice card: aCard	cart := aCart.	price := aPrice.	card := aCard! !!Transaction methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 19:28'!card	^ card! !!Transaction methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 19:28'!cart	^ cart! !!Transaction methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 19:28'!price	^ price! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Transaction class	instanceVariableNames: ''!!Transaction class methodsFor: 'initialization' stamp: 'JulianBayardo 10/31/2017 16:09'!cart: aCart price: aPrice card: aCard	^ super new		initializeCart: aCart		price: aPrice		card: aCard! !