Exception subclass: #AmountInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #Book	instanceVariableNames: 'titulo autor isbn'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Book methodsFor: 'initialization' stamp: 'LosPibes 10/26/2017 18:48'!isbn: ISBN title: aTitle author: anAuthor	isbn := ISBN.	titulo := aTitle.	autor := anAuthor.! !!Book methodsFor: 'accessing' stamp: 'LosPibes 10/26/2017 18:48'!title	^ titulo! !!Book methodsFor: 'accessing' stamp: 'LosPibes 10/26/2017 18:57'!hash	^ self isbn hash.! !!Book methodsFor: 'accessing' stamp: 'LosPibes 10/26/2017 18:45'!isbn	^ isbn! !!Book methodsFor: 'accessing' stamp: 'LosPibes 10/26/2017 18:57'!= aBook	^ self isbn = aBook isbn.! !!Book methodsFor: 'accessing' stamp: 'LosPibes 10/26/2017 18:47'!author	^ autor! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Book class	instanceVariableNames: ''!!Book class methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/26/2017 18:48'!isbn: ISBN title: titulo author: autor	^ Book new		isbn: ISBN		title: titulo		author: autor.! !TestCase subclass: #BookTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!BookTests methodsFor: 'tests' stamp: 'LosPibes 10/30/2017 20:28'!test01equalsUsingISBN	| book book2 |	book := Book isbn: 01 title: 'Test' author: 'Pirulo'.	book2 := Book isbn: 01 title: 'Test' author: 'Pirulo'.	self assert: book equals: book2.	self assert: (book hash) equals: (book2 hash).! !Object subclass: #Cart	instanceVariableNames: 'catalogue items'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Cart methodsFor: 'accessing' stamp: 'JulianBayardo 10/31/2017 17:35'!isEmpty	^ items isEmpty.! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:30'!size	^ items size! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:30'!list	| aList |	aList := Set new.	items		doWithOccurrences: [ :anItem :occurrences | aList add: (Association key: anItem value: occurrences) ].	^ aList! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:31'!amount: anItem	^ items occurrencesOf: anItem! !!Cart methodsFor: 'accessing' stamp: 'JulianBayardo 11/2/2017 17:37'!price	^ catalogue priceCart: self list! !!Cart methodsFor: 'initialization' stamp: 'LosPibes 10/30/2017 20:30'!initialize	items := Bag new! !!Cart methodsFor: 'initialization' stamp: 'LosPibes 10/26/2017 20:51'!initializeCatalogue: aCatalogue 	catalogue := aCatalogue.! !!Cart methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 17:19'!add: anItem amount: anAmount	(catalogue includes: anItem)		ifFalse: [ ^ ItemUnknownException new signal ].	(anAmount isKindOf: Integer)		ifFalse: [ ^ AmountInvalidException new signal ].	anAmount > 0		ifFalse: [ ^ AmountInvalidException new signal ].	items add: anItem withOccurrences: anAmount.	^ self! !!Cart methodsFor: 'adding' stamp: 'LosPibes 10/30/2017 20:29'!add: anItem	^ self add: anItem amount: 1.! !!Cart methodsFor: 'purchase' stamp: 'JulianBayardo 10/31/2017 15:59'!purchaseRemoveFromStock	^ catalogue doPurchase: (self list)! !!Cart methodsFor: 'purchase' stamp: 'JulianBayardo 10/31/2017 15:59'!purchaseCheckEnoughStock	^ catalogue canPurchase: (self list).! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cart class	instanceVariableNames: ''!!Cart class methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/26/2017 20:59'!withCatalogue: aCatalogue	^ super new initializeCatalogue: aCatalogue! !Exception subclass: #CartEmptyException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!TestCase subclass: #CartTests	instanceVariableNames: 'defaultCart'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:01'!test05listOfItemsOfEmptyCartIsEmpty	self assert: defaultCart list size equals: 0! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:33'!test13priceSingle	defaultCart add: 1.	self assert: defaultCart price equals: 10! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test03canHoldMultipleItems	| book book2 |	book := 1.	book2 := 2.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: (defaultCart amount: book2) equals: 0.	defaultCart add: book2.	self assert: (defaultCart amount: book2) equals: 1.	self assert: defaultCart size equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test11amountsMustBeGreaterThanZero	| book |	book := 231.	self should: [ defaultCart add: book amount: 0 ] raise: AmountInvalidException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test01itemIsPresentAfterAdding	| book |	book := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: defaultCart size equals: 1.! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test02itemCanBeAddedMultipleTimes	| book |	book := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book amount: 2.	self assert: (defaultCart amount: book) equals: 2.	self assert: defaultCart size equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:34'!test16priceTwoMultipleUnits	defaultCart add: 1.	defaultCart add: 1.	defaultCart add: 231.	defaultCart add: 231.	self assert: defaultCart price equals: 66! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test10amountsMustBeIntegers	| book |	book := 231.	self should: [ defaultCart add: book amount: 1 / 3 ] raise: AmountInvalidException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:01'!test08ListOfMultipleItemsHasAccurateCounts	| book list computedList book2 |	book := 231.	defaultCart add: book amount: 2.	book2 := 321.	defaultCart add: book2.	list := Set new.	list add: (Association key: 231 value: 2).	list add: (Association key: 321 value: 1).	computedList := defaultCart list.	self assert: computedList size equals: 2.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:33'!test14priceTwo	defaultCart add: 1.	defaultCart add: 2.	self assert: defaultCart price equals: 23! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:33'!test12priceEmpty	self assert: defaultCart price equals: 0! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test09itemMustBeInCatalogue	| book catalogue book2 cart |	book := 2312.	book2 := 23111.	catalogue := Set new.	catalogue add: book.	cart := Cart withCatalogue: catalogue.	self should: [ cart add: book2 ] raise: ItemUnknownException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:01'!test06ListOfSingleItemHasAccurateCounts	| book list computedList |	book := 231.	defaultCart add: book.	list := Set new.	list add: (Association key: 231 value: 1).	computedList := defaultCart list.	self assert: computedList size equals: 1.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:01'!test07ListOfSingleItemTwiceHasAccurateCounts	| book list computedList |	book := 231.	defaultCart add: book amount: 2.	list := Set new.	list add: (Association key: 231 value: 2).	computedList := defaultCart list.	self assert: computedList size equals: 1.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:27'!test00newCarIsEmpty	self assert: defaultCart isEmpty! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:26'!instanceDefaultCatalogue	| catalogue |	catalogue := PriceTable new.	catalogue add: 1 price: 10 stock: 20.	catalogue add: 2 price: 13 stock: 2.	catalogue add: 231 price: 23 stock: 4.	catalogue add: 321 price: 433 stock: 4.	catalogue add: 444 price: 111 stock: 0.	^ catalogue! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:33'!test15priceSingleMultipleUnits	defaultCart add: 1.	defaultCart add: 1.	self assert: defaultCart price equals: 20! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:29'!test04canSearchByBookAlias	| book book2 |	book := 1.	book2 := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: (defaultCart amount: book2) equals: 1.	defaultCart add: book2.	self assert: (defaultCart amount: book) equals: 2.	self assert: (defaultCart amount: book2) equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:27'!setUp	defaultCart := Cart withCatalogue: self instanceDefaultCatalogue.! !Exception subclass: #CartTimeOutException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #Cashier	instanceVariableNames: 'paymentProcessor salesBook'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Cashier methodsFor: 'purchase' stamp: 'JulianBayardo 11/1/2017 17:14'!checkout: aCart for: aCard currentDate: aTimestamp	| price transaction |	self validateCart: aCart.	self validateCard: aCard currentMonthOfYear: aTimestamp monthOfYear.	price := aCart price.	paymentProcessor debit: price into: aCard.	transaction := Transaction cart: aCart price: price card: aCard.	salesBook add: transaction.	aCart purchaseRemoveFromStock.	^ transaction! !!Cashier methodsFor: 'validation' stamp: 'JulianBayardo 11/1/2017 15:58'!validateCard: aCard currentMonthOfYear: aMonthOfYear	(aCard hasExpired: aMonthOfYear)		ifTrue: [ CreditCardExpiredException new signal ].! !!Cashier methodsFor: 'validation' stamp: 'JulianBayardo 11/1/2017 17:19'!validateCart: aCart	aCart isEmpty		ifTrue: [ CartEmptyException new signal ].	aCart purchaseCheckEnoughStock ifFalse: [ OutOfStockException new signal. ].! !!Cashier methodsFor: 'initialization' stamp: 'JulianBayardo 11/1/2017 17:13'!processor: aPaymentProcessor salesBook: aSalesBook	paymentProcessor := aPaymentProcessor .	salesBook := aSalesBook.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cashier class	instanceVariableNames: ''!!Cashier class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/1/2017 17:13'!processor: aPaymentProcessor salesBook: aSalesBook	^ Cashier new processor: aPaymentProcessor salesBook: aSalesBook.! !TestCase subclass: #CashierTests	instanceVariableNames: 'salesBook defaultCatalogue defaultCart cashier debitBehavior mp'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:07'!test08checkoutWithStolenCardFails	| currentDate card |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | CreditCardStolenException new signal ].	self should: [ cashier checkout: defaultCart for: card currentDate: currentDate ] raise: CreditCardStolenException.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:05'!test04checkoutAddsToSaleBookAndUpdatesStock	| currentDate transaction card debitAmount |	defaultCart add: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := cashier checkout: defaultCart for: card currentDate: currentDate.	self assert: transaction cart equals: defaultCart.	self assert: transaction price equals: defaultCart price.	self assert: transaction card equals: card.	self assert: debitAmount equals: transaction  price.	self assert: salesBook first equals: transaction.	self assert: salesBook size equals: 1.	self assert: (self instanceDefaultCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 1! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:06'!test05checkoutMultipleAddsToSaleBookAndUpdatesStock	| currentDate transaction card originalCatalogue debitAmount |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := cashier checkout: defaultCart for: card currentDate: currentDate.	self assert: transaction cart equals: defaultCart.	self assert: transaction price equals: defaultCart price.	self assert: transaction card equals: card.	self assert: debitAmount equals: transaction price.	self assert: salesBook first equals: transaction.	self assert: salesBook size equals: 1.	originalCatalogue := self instanceDefaultCatalogue.	self assert: (originalCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 5.	self assert: (originalCatalogue stock: 2) equals: (defaultCatalogue stock: 2) + 1! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:06'!test06checkoutManyAddsToSalesBookAndUpdatesAppropriately	| currentDate transaction1 card originalCatalogue anotherCart transaction2 debitAmount |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	anotherCart := Cart withCatalogue: defaultCatalogue.	anotherCart add: 1 amount: 6.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	debitAmount := 0.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := debitAmount + anAmount ].	transaction1 := cashier checkout: defaultCart for: card currentDate: currentDate.	self assert: debitAmount equals: transaction1 price.	transaction2 := cashier checkout: anotherCart for: card currentDate: currentDate.	self assert: debitAmount equals: transaction1 price + transaction2 price.	self assert: salesBook first equals: transaction1.	self assert: salesBook second equals: transaction2.	self assert: salesBook size equals: 2.	originalCatalogue := self instanceDefaultCatalogue.	self assert: (originalCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 11.	self assert: (originalCatalogue stock: 2) equals: (defaultCatalogue stock: 2) + 1! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/3/2017 00:17'!test02checkoutNotEnoughStock	defaultCart add: 444.		debitBehavior := [ :anAmount :aCreditCard | self fail ].	self should: [ cashier checkout: defaultCart for: nil currentDate: nil ] raise: OutOfStockException.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:04'!setUp	salesBook := OrderedCollection new.	defaultCatalogue := self instanceDefaultCatalogue.	defaultCart := Cart withCatalogue: defaultCatalogue.	mp := MerchantProcessorSimulator new .	cashier := Cashier processor: mp salesBook: salesBook .! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/3/2017 00:17'!test03checkoutExpiredCard	| currentDate |	defaultCart add: 1.	currentDate := January first , 2004.		debitBehavior := [ :anAmount :aCreditCard | self fail ].	self should: [ cashier checkout: defaultCart for: (self instanceExpiredCreditCard: currentDate) currentDate: currentDate ] raise: CreditCardExpiredException.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:07'!test07checkoutWithFakeCardFails	| currentDate card |	defaultCart add: 1 amount: 5.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | CreditCardUnknownException new signal ].	self should: [ cashier checkout: defaultCart for: card currentDate: currentDate ] raise: CreditCardUnknownException.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:07'!test09checkoutNotEnoughFundsFails	| currentDate card |	defaultCart add: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | CreditCardNotEnoughFundsException new signal ].	self should: [ cashier checkout: defaultCart for: card currentDate: currentDate ] raise: CreditCardNotEnoughFundsException.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/3/2017 00:17'!test01checkoutEmpty	debitBehavior := [ :anAmount :aCreditCard | self fail ].	self should: [ cashier checkout: defaultCart for: nil currentDate: nil ] raise: CartEmptyException.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !!CashierTests methodsFor: 'data' stamp: 'LosPibes 10/30/2017 21:20'!instanceNonExpiredCreditCard: currentDate	^ CreditCard		owner: 'Roberto Bolanos'		number: 1234567891234567		expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear! !!CashierTests methodsFor: 'data' stamp: 'LosPibes 10/30/2017 21:05'!instanceExpiredCreditCard: currentDate	^ CreditCard		owner: 'Roberto Bolanos'		number: 1234567891234567		expiration: (currentDate previous: (TimeUnits month with: 1)) monthOfYear! !!CashierTests methodsFor: 'data' stamp: 'JulianBayardo 10/31/2017 16:26'!instanceDefaultCatalogue	| catalogue |	catalogue := PriceTable new.	catalogue add: 1 price: 10 stock: 20.	catalogue add: 2 price: 13 stock: 2.	catalogue add: 231 price: 23 stock: 4.	catalogue add: 321 price: 433 stock: 4.	catalogue add: 444 price: 111 stock: 0.	^ catalogue! !Object subclass: #CreditCard	instanceVariableNames: 'name number expiration'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CreditCard methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 20:53'!owner: aName number: aNumber expiration: aDate 	name := aName.	number := aNumber.	expiration := aDate.! !!CreditCard methodsFor: '*Aconcagua-Extensions' stamp: 'LosPibes 10/30/2017 21:03'!hasExpired: aMonthOfYear	^ self expiration < aMonthOfYear.! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:15'!expiration	^ expiration! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:15'!number	^ number.! !!CreditCard methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:05'!hash	^ number hash! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:14'!owner	^ name! !!CreditCard methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:05'!= aCreditCard	^ number = aCreditCard number! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CreditCard class	instanceVariableNames: ''!!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 20:53'!owner: aName number: aNumber expiration: aDate 	^ super new owner: aName number: aNumber expiration: aDate.! !Exception subclass: #CreditCardExpiredException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardNotEnoughFundsException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardNumberInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardOwnerNameInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardStolenException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardUnknownException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #InvalidCartException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #InvalidUserException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #ItemUnknownException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #MerchantProcessor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!MerchantProcessor methodsFor: 'accessing' stamp: 'JulianBayardo 11/2/2017 17:44'!debit: anAmount into: aCard	" aCard es un objeto CreditCard"	| owner number expiration |	owner := self formatOwner: aCard.	number := self formatNumber: aCard.	expiration := self formatExpiration: aCard.! !MerchantProcessor subclass: #MerchantProcessorSimulator	instanceVariableNames: 'debitBehavior'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!MerchantProcessorSimulator methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 01:58'!debit: anAmount into: aCreditCard	^ debitBehavior value: anAmount value: aCreditCard ! !!MerchantProcessorSimulator methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 02:04'!debitBehavior: aBlock	debitBehavior := aBlock.! !Exception subclass: #OutOfStockException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #PriceInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #PriceTable	instanceVariableNames: 'prices stock'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!PriceTable methodsFor: 'purchase' stamp: 'JulianBayardo 11/1/2017 16:02'!canPurchase: aCollectionOfPurchases	^ aCollectionOfPurchases		noneSatisfy: [ :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			(self stock: item) < amount ]! !!PriceTable methodsFor: 'purchase' stamp: 'JulianBayardo 11/1/2017 16:02'!doPurchase: aCollectionOfPurchases 	aCollectionOfPurchases		do: [ :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			amount timesRepeat: [ stock remove: item ifAbsent: [ ] ]].! !!PriceTable methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 16:03'!add: anItem price: aPrice	^ self add: anItem price: aPrice stock: 0! !!PriceTable methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 17:19'!add: anItem price: aPrice stock: anAmount	aPrice > 0		ifFalse: [ ^ PriceInvalidException new signal ].	(anAmount isKindOf: Integer)		ifFalse: [ ^ AmountInvalidException new signal ].	anAmount >= 0		ifFalse: [ ^ AmountInvalidException new signal ].	stock add: anItem withOccurrences: anAmount.	prices add: (Association key: anItem value: aPrice)! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 16:03'!includes: anItem	^ stock includes: anItem! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:19'!price: anItem		^ [ prices at: anItem ] on: KeyNotFound do: [ ItemUnknownException new signal. ]! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:19'!stock: anItem	(self includes: anItem) ifFalse: [ ItemUnknownException new signal ].	^ stock occurrencesOf: anItem! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/2/2017 17:37'!priceCart: aCollectionOfPurchases	^ aCollectionOfPurchases 		inject: 0		into: [ :anAccumulatedPrice :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			anAccumulatedPrice + ((self price: item) * amount) ]! !!PriceTable methodsFor: 'initialization' stamp: 'LosPibes 10/30/2017 17:27'!initialize	stock := Bag new.	prices := Dictionary new.! !!PriceTable methodsFor: 'testing' stamp: 'LosPibes 10/30/2017 19:47'!stock	^ stock! !TestCase subclass: #PriceTableTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:04'!test02singlePrice	| table |	table := PriceTable new.	table add: 2 price: 5 stock: 0.	self assert: (table includes: 2) equals: true.	self assert: (table price: 2) equals: 5.	self assert: (table stock: 2) equals: 0.		self assert: (table includes: 5) equals: false.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test01emptyCanNotPrice	| table |	table := PriceTable new.	self assert: (table includes: 2) equals: false.	self should: [ table price: 2 ] raise: ItemUnknownException.	self should: [ table stock: 2 ] raise: ItemUnknownException! !!PriceTableTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:01'!test01InvalidUserDontValidate	| table |	table := PriceTable new.	self assert: (table includes: 2) equals: false.	self should: [ table price: 2 ] raise: ItemUnknownException.	self should: [ table stock: 2 ] raise: ItemUnknownException! !Object subclass: #RESTInterface	instanceVariableNames: 'users catalog indexOfCarts indexCounter cashier mp transactions usersOfCarts timer'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!RESTInterface methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 18:55'!initializeWithUsers: aDictionary catalog: aCatalog andMP: anMP	users := aDictionary .	catalog := aCatalog .	indexOfCarts := Dictionary new .	indexCounter := 0 .	mp := anMP.	cashier := Cashier processor: mp salesBook: OrderedCollection new .	transactions := Dictionary new .	usersOfCarts := Dictionary new .	timer := TimerNow initialize .! !!RESTInterface methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 18:55'!initializeWithUsers: aDictionary catalog: aCatalog mp: anMP andTimer: aTimer	users := aDictionary .	catalog := aCatalog .	indexOfCarts := Dictionary new .	indexCounter := 0 .	mp := anMP.	cashier := Cashier processor: mp salesBook: OrderedCollection new .	transactions := Dictionary new .	usersOfCarts := Dictionary new .	timer := aTimer .! !!RESTInterface methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 11:31'!initializeUserVariables: aUser	transactions at: aUser put: OrderedCollection new .! !!RESTInterface methodsFor: 'adding' stamp: 'DamianFurman 11/5/2017 14:11'!addToCart: id bookIsbn: anISBN quantity: aQuantity	| cart |	cart := (self findCart: id) .	(timer checkTimeoutFor: id) ifFalse: [ CartTimeOutException new signal ] .	cart add: anISBN amount: aQuantity .	timer tickFor: (usersOfCarts at: id) .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 01:25'!findCart: anId	^indexOfCarts at: anId ifAbsent: [^InvalidCartException new signal .] .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 10:46'!listPurchasesFor: aUser withPass: aPass	(self validateFor: aUser withPass: aPass )		ifTrue: [ ^self transactionsFor: aUser ] .	^InvalidUserException new signal .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 11:42'!referenceCart: aCart forUser: anUser	| id |	id := self nextIndex .	indexOfCarts at: id put: aCart .	usersOfCarts at: id put: anUser .	^id .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 13:54'!createCartFor: aUser withPass: aPass	| id |	(self validateFor: aUser withPass: aPass )		ifTrue: [ 			transactions at: aUser ifAbsent: [ transactions at: aUser put: OrderedCollection new ] .			id := self referenceCart: (Cart withCatalogue: catalog) forUser: aUser .			timer tickFor: id.			^ id.			] .	^InvalidUserException new signal .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 00:32'!validateFor: aUser withPass: aPass	| pass |	pass := users at: aUser ifAbsent: [ ^false.] .	(pass = aPass) ifFalse: [ ^false. ] .	^true! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 11:22'!transactionsFor: aUser	^(transactions at: aUser)! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 19:20'!checkout: aCartId withCard: aCreditCard currentDate: aCurrentDate	| cart transaction |	cart := self findCart: aCartId .	(timer checkTimeoutFor: aCartId ) ifFalse: [ ^CartTimeOutException new signal] .	transaction := cashier checkout: cart for: aCreditCard currentDate: aCurrentDate .	(transactions at: (usersOfCarts at: aCartId)) add: transaction .	^ transaction .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 14:12'!listCart: anId	| cart |	cart := indexOfCarts at: anId ifAbsent: [^InvalidCartException new signal .] .	(timer checkTimeoutFor: anId) ifFalse: [ CartTimeOutException new signal ] .	timer tickFor: (usersOfCarts at: anId) .	^ cart list .! !!RESTInterface methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 12:03'!nextIndex	indexCounter := (indexCounter + 1).	^indexCounter.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RESTInterface class	instanceVariableNames: ''!!RESTInterface class methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 02:30'!initializeWithUsers: aDictionary catalog: aCatalog andMP: anMP	^ self new initializeWithUsers: aDictionary catalog: aCatalog andMP: anMP.! !!RESTInterface class methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 18:58'!initializeWithUsers: aDictionary catalog: aCatalog mp: anMP andTimer: aTimer	^ self new initializeWithUsers: aDictionary catalog: aCatalog mp: anMP andTimer: aTimer.! !TestCase subclass: #RESTInterfaceTests	instanceVariableNames: 'restInterface catalog mp timer'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!RESTInterfaceTests methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 19:01'!setUp	| init book1 book7 |	init := Dictionary new .	init at: 'ValidUser' put: 'ValidPass' .	init at: 'AnotherValidUser' put: 'AnotherValidPass' .	catalog := PriceTable new.	book1 := 1 .	catalog add: book1 price: 10 stock: 7 .	book7 := 7 .	catalog add: book7 price: 8 stock: 9.	mp := MerchantProcessorSimulator new .	timer := TimerSimulator initialize .	restInterface := RESTInterface initializeWithUsers: init catalog: catalog mp: mp andTimer: timer.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:28'!test08CantAddToInvalidCart	| id |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	self should: [restInterface addToCart: (id + 10) bookIsbn: 1 quantity: 2 .] raise: InvalidCartException .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:03'!test05CanCreateCartAndGetId	| id cart |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	cart := restInterface findCart: id .	self assert: (cart list isEmpty) .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 19:17'!test14CantAddToExpiredCart	| id now |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	now := Time now .	timer setCurrentTime: (Time hour: (now hours + 1) minute: (now minutes) second: (now second) ).	self should: [restInterface addToCart: id bookIsbn: 1 quantity: 2 .] raise: CartTimeOutException.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:01'!test01InvalidUserDontValidate	self assert: (restInterface validateFor: 'Pepe' withPass: '123456' ) not .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 11:21'!test04CanIndexCartAndReferenceIt	| cart book id cart2 book7 |	"Originally this test checked if it was possible to reference any cart, but now it's not possible to reference it whitout being asociated to an User so it only checks that is possible to index carts created throug the rest interface"	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	cart := restInterface findCart: id .	book := 1 .	cart add: book amount: 3.	book7 := 7 .	cart add: book7 .	id := restInterface referenceCart: cart forUser: 'ValidUser' .	cart2 := restInterface findCart: id .	self assert: (cart2 amount: book) equals: 3 .	self assert: (cart2 amount: book7) equals: 1 .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 11:51'!test12CanReferenceUsersPurchaseHistory	| id currentDate creditCard debitAmount transaction transactionList id2 id3 transaction2 transactionList2 |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id2 := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id3 := restInterface createCartFor: 'AnotherValidUser' withPass: 'AnotherValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	restInterface addToCart: id2 bookIsbn: 7  quantity: 3 .	restInterface addToCart: id3 bookIsbn: 1  quantity: 4 . 	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := restInterface checkout: id withCard: creditCard currentDate: currentDate .	transaction2 := restInterface checkout: id3 withCard: creditCard currentDate: currentDate .	transactionList := restInterface listPurchasesFor: 'ValidUser' withPass: 'ValidPass' .	transactionList2 := restInterface listPurchasesFor: 'AnotherValidUser' withPass: 'AnotherValidPass' .	self assert: (transactionList includes: transaction) .	self assert: (transactionList includes: transaction2) not .	self assert: (transactionList size) equals: 1.	self assert: (transactionList2 includes: transaction2) .	self assert: (transactionList2 includes: transaction) not .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 19:18'!test15CantListFromExpiredCart	| id now |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	now := Time now .	timer setCurrentTime: (Time hour: (now hours + 1) minute: (now minutes) second: (now second) ).	self should: [restInterface listCart: id.] raise: CartTimeOutException.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:00'!test03ValidUserValidates		self assert: (restInterface validateFor: 'ValidUser' withPass: 'ValidPass' ) .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 19:25'!test16CantCheckoutFromExpiredCart	| id currentDate creditCard debitAmount now |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	now := Time now .	timer setCurrentTime: (Time hour: (now hours + 1) minute: (now minutes) second: (now second) ).	self should: [restInterface checkout: id withCard: creditCard currentDate: currentDate .] raise: CartTimeOutException.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 10:35'!test11CantCheckoutWithInvalidCreditCart	| id creditCard currentDate transaction |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate previous: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | self fail ].	self should: [transaction := restInterface checkout: id withCard: creditCard currentDate: currentDate .] raise: CreditCardExpiredException .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:28'!test09CantListToInvalidCart	| id |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	self should: [restInterface listCart: (id + 10) .] raise: InvalidCartException .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 12:24'!test13CanReferenceUsersPurchaseHistoryForInvalidPass	| id currentDate creditCard debitAmount transaction transactionList id2 id3 transaction2 |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id2 := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id3 := restInterface createCartFor: 'AnotherValidUser' withPass: 'AnotherValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	restInterface addToCart: id2 bookIsbn: 7  quantity: 3 .	restInterface addToCart: id3 bookIsbn: 1  quantity: 4 . 	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := restInterface checkout: id withCard: creditCard currentDate: currentDate .	transaction2 := restInterface checkout: id3 withCard: creditCard currentDate: currentDate .	self should: [transactionList := restInterface listPurchasesFor: 'ValidUser' withPass: 'InvalidPass' .] raise: InvalidUserException .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:37'!test10CanCheckoutWithValidCartAndCreditCart	| id creditCard currentDate debitAmount transaction |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := restInterface checkout: id withCard: creditCard currentDate: currentDate .	self assert: transaction cart equals: (restInterface findCart: id) .	self assert: transaction card equals: creditCard.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:01'!test02ValidUserInvalidPassDontValidate	self assert: (restInterface validateFor: 'ValidUser' withPass: '123456' ) not .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:20'!test07CanListValidCart	| id list |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	list := restInterface listCart: id .	self assert: (list includes: (Association key: 1 value: 2) ) .	self assert: (list includes: (Association key: 7 value: 1) ) .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:20'!test06CanAddToValidCart	| id cart |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	cart := restInterface findCart: id .	self assert: (cart amount: 1) equals: 2 .	self assert: (cart amount: 7) equals: 1! !Object subclass: #TestData	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #Timer	instanceVariableNames: 'users carts'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Timer methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 13:40'!tickFor: aCartId	carts at: aCartId put: Time now . ! !!Timer methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 13:40'!initialize	carts := Dictionary new.! !!Timer methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 18:42'!currentTime	self subclassResponsibility  .! !!Timer methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 18:41'!checkTimeoutFor: aCartId	| now |	now := self currentTime .	^((now hours) * 60 + now minutes < (((carts at: aCartId) hours) * 60 + (carts at: aCartId) minutes + 30)) .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Timer class	instanceVariableNames: ''!!Timer class methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 13:33'!initialize	^self new initialize .! !Timer subclass: #TimerNow	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!TimerNow methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 18:46'!currentTime	^Time now.! !Timer subclass: #TimerSimulator	instanceVariableNames: 'currentTime'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!TimerSimulator methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 18:59'!currentTime	^currentTime ifNil: [ ^Time now ] .! !!TimerSimulator methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 19:00'!setCurrentTime: aTime	currentTime := aTime .! !Object subclass: #Transaction	instanceVariableNames: 'cart price card timestamp'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Transaction methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 19:28'!card	^ card! !!Transaction methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 19:28'!cart	^ cart! !!Transaction methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 19:28'!price	^ price! !!Transaction methodsFor: 'initialization' stamp: 'JulianBayardo 10/31/2017 15:42'!initializeCart: aCart price: aPrice card: aCard	cart := aCart.	price := aPrice.	card := aCard! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Transaction class	instanceVariableNames: ''!!Transaction class methodsFor: 'initialization' stamp: 'JulianBayardo 10/31/2017 16:09'!cart: aCart price: aPrice card: aCard	^ super new		initializeCart: aCart		price: aPrice		card: aCard! !Timer initialize!