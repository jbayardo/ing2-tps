Exception subclass: #AmountInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #Cart	instanceVariableNames: 'catalogue items'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Cart methodsFor: 'initialization' stamp: 'LosPibes 10/30/2017 20:30'!initialize	items := Bag new! !!Cart methodsFor: 'initialization' stamp: 'LosPibes 10/26/2017 20:51'!initializeCatalogue: aCatalogue 	catalogue := aCatalogue.! !!Cart methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 17:19'!add: anItem amount: anAmount	(catalogue includes: anItem)		ifFalse: [ ^ ItemUnknownException new signal ].	(anAmount isKindOf: Integer)		ifFalse: [ ^ AmountInvalidException new signal ].	anAmount > 0		ifFalse: [ ^ AmountInvalidException new signal ].	items add: anItem withOccurrences: anAmount.	^ self! !!Cart methodsFor: 'adding' stamp: 'LosPibes 10/30/2017 20:29'!add: anItem	^ self add: anItem amount: 1.! !!Cart methodsFor: 'purchase' stamp: 'JulianBayardo 11/5/2017 17:44'!isValidPurchase	^ catalogue hasStockForPurchase: (self list).! !!Cart methodsFor: 'purchase' stamp: 'JulianBayardo 11/5/2017 17:04'!purchase	^ catalogue purchase: (self list)! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:30'!size	^ items size! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:30'!list	| aList |	aList := Set new.	items		doWithOccurrences: [ :anItem :occurrences | aList add: (Association key: anItem value: occurrences) ].	^ aList! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:31'!amount: anItem	^ items occurrencesOf: anItem! !!Cart methodsFor: 'accessing' stamp: 'JulianBayardo 11/5/2017 17:03'!price	^ catalogue priceMany: self list! !!Cart methodsFor: 'accessing' stamp: 'JulianBayardo 10/31/2017 17:35'!isEmpty	^ items isEmpty.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cart class	instanceVariableNames: ''!!Cart class methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/26/2017 20:59'!withCatalogue: aCatalogue	^ super new initializeCatalogue: aCatalogue! !Exception subclass: #CartEmptyException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CartInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!TestCase subclass: #CartTests	instanceVariableNames: 'defaultCart'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:29'!test04canSearchByBookAlias	| book book2 |	book := 1.	book2 := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: (defaultCart amount: book2) equals: 1.	defaultCart add: book2.	self assert: (defaultCart amount: book) equals: 2.	self assert: (defaultCart amount: book2) equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:27'!test00newCarIsEmpty	self assert: defaultCart isEmpty! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test03canHoldMultipleItems	| book book2 |	book := 1.	book2 := 2.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: (defaultCart amount: book2) equals: 0.	defaultCart add: book2.	self assert: (defaultCart amount: book2) equals: 1.	self assert: defaultCart size equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:01'!test05listOfItemsOfEmptyCartIsEmpty	self assert: defaultCart list size equals: 0! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test09itemMustBeInCatalogue	| book catalogue book2 cart |	book := 2312.	book2 := 23111.	catalogue := Set new.	catalogue add: book.	cart := Cart withCatalogue: catalogue.	self should: [ cart add: book2 ] raise: ItemUnknownException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test10amountsMustBeIntegers	| book |	book := 231.	self should: [ defaultCart add: book amount: 1 / 3 ] raise: AmountInvalidException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:06'!test07listOfSingleItemTwiceHasAccurateCounts	| book list computedList |	book := 231.	defaultCart add: book amount: 2.	list := Set new.	list add: (Association key: 231 value: 2).	computedList := defaultCart list.	self assert: computedList size equals: 1.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:06'!test06listOfSingleItemHasAccurateCounts	| book list computedList |	book := 231.	defaultCart add: book.	list := Set new.	list add: (Association key: 231 value: 1).	computedList := defaultCart list.	self assert: computedList size equals: 1.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:06'!test08listOfMultipleItemsHasAccurateCounts	| book list computedList book2 |	book := 231.	defaultCart add: book amount: 2.	book2 := 321.	defaultCart add: book2.	list := Set new.	list add: (Association key: 231 value: 2).	list add: (Association key: 321 value: 1).	computedList := defaultCart list.	self assert: computedList size equals: 2.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:27'!setUp	defaultCart := Cart withCatalogue: self instanceDefaultCatalogue.! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test11amountsMustBeGreaterThanZero	| book |	book := 231.	self should: [ defaultCart add: book amount: 0 ] raise: AmountInvalidException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test02itemCanBeAddedMultipleTimes	| book |	book := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book amount: 2.	self assert: (defaultCart amount: book) equals: 2.	self assert: defaultCart size equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test01itemIsPresentAfterAdding	| book |	book := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: defaultCart size equals: 1.! !!CartTests methodsFor: 'data' stamp: 'JulianBayardo 10/31/2017 16:26'!instanceDefaultCatalogue	| catalogue |	catalogue := PriceTable new.	catalogue add: 1 price: 10 stock: 20.	catalogue add: 2 price: 13 stock: 2.	catalogue add: 231 price: 23 stock: 4.	catalogue add: 321 price: 433 stock: 4.	catalogue add: 444 price: 111 stock: 0.	^ catalogue! !Exception subclass: #CartTimeOutException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #Cashier	instanceVariableNames: 'paymentProcessor salesBook'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Cashier methodsFor: 'purchase' stamp: 'JulianBayardo 11/6/2017 10:54'!checkout: aCart for: aCard currentDate: aTimestamp	| price payment transaction |	self validateCart: aCart.	self validateCard: aCard currentMonthOfYear: aTimestamp monthOfYear.	price := aCart price.	payment := paymentProcessor debit: price into: aCard.	transaction := CashierTransaction cart: aCart payment: payment.	salesBook add: transaction.	aCart purchase.	^ transaction! !!Cashier methodsFor: 'initialization' stamp: 'JulianBayardo 11/1/2017 17:13'!processor: aPaymentProcessor salesBook: aSalesBook	paymentProcessor := aPaymentProcessor .	salesBook := aSalesBook.! !!Cashier methodsFor: 'validation' stamp: 'JulianBayardo 11/1/2017 15:58'!validateCard: aCard currentMonthOfYear: aMonthOfYear	(aCard hasExpired: aMonthOfYear)		ifTrue: [ CreditCardExpiredException new signal ].! !!Cashier methodsFor: 'validation' stamp: 'JulianBayardo 11/5/2017 17:04'!validateCart: aCart	aCart isEmpty		ifTrue: [ CartEmptyException new signal ].	aCart isValidPurchase ifFalse: [ OutOfStockException new signal. ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cashier class	instanceVariableNames: ''!!Cashier class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/1/2017 17:13'!processor: aPaymentProcessor salesBook: aSalesBook	^ Cashier new processor: aPaymentProcessor salesBook: aSalesBook.! !TestCase subclass: #CashierTests	instanceVariableNames: 'salesBook defaultCatalogue defaultCart cashier mp'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CashierTests methodsFor: 'data' stamp: 'LosPibes 10/30/2017 21:20'!instanceNonExpiredCreditCard: currentDate	^ CreditCard		owner: 'Roberto Bolanos'		number: 1234567891234567		expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear! !!CashierTests methodsFor: 'data' stamp: 'JulianBayardo 10/31/2017 16:26'!instanceDefaultCatalogue	| catalogue |	catalogue := PriceTable new.	catalogue add: 1 price: 10 stock: 20.	catalogue add: 2 price: 13 stock: 2.	catalogue add: 231 price: 23 stock: 4.	catalogue add: 321 price: 433 stock: 4.	catalogue add: 444 price: 111 stock: 0.	^ catalogue! !!CashierTests methodsFor: 'data' stamp: 'LosPibes 10/30/2017 21:05'!instanceExpiredCreditCard: currentDate	^ CreditCard		owner: 'Roberto Bolanos'		number: 1234567891234567		expiration: (currentDate previous: (TimeUnits month with: 1)) monthOfYear! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 10:58'!test05checkoutMultipleAddsToSaleBookAndUpdatesStock	| currentDate transaction card originalCatalogue debitAmount |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := cashier checkout: defaultCart for: card currentDate: currentDate.	self assert: debitAmount equals: defaultCart price.	self assert: transaction price equals: debitAmount.	self assert: salesBook first equals: transaction.	self assert: salesBook size equals: 1.	originalCatalogue := self instanceDefaultCatalogue.	self assert: (originalCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 5.	self assert: (originalCatalogue stock: 2) equals: (defaultCatalogue stock: 2) + 1! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:07'!test07checkoutWithFakeCardFails	| currentDate card |	defaultCart add: 1 amount: 5.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | CreditCardUnknownException new signal ].	self should: [ cashier checkout: defaultCart for: card currentDate: currentDate ] raise: CreditCardUnknownException.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 16:58'!test03checkoutExpiredCard	| currentDate |	defaultCart add: 1.	currentDate := January first , 2004.	mp debitBehavior: [ :anAmount :aCreditCard | self fail ].	self should: [ cashier checkout: defaultCart for: (self instanceExpiredCreditCard: currentDate) currentDate: currentDate ] raise: CreditCardExpiredException.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:07'!test09checkoutNotEnoughFundsFails	| currentDate card |	defaultCart add: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | CreditCardNotEnoughFundsException new signal ].	self should: [ cashier checkout: defaultCart for: card currentDate: currentDate ] raise: CreditCardNotEnoughFundsException.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 10:58'!test06checkoutManyAddsToSalesBookAndUpdatesAppropriately	| currentDate transaction1 card originalCatalogue anotherCart transaction2 debitAmount |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	anotherCart := Cart withCatalogue: defaultCatalogue.	anotherCart add: 1 amount: 6.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	debitAmount := 0.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := debitAmount + anAmount ].	transaction1 := cashier checkout: defaultCart for: card currentDate: currentDate.	self assert: debitAmount equals: defaultCart price.	self assert: transaction1 price equals: debitAmount.	transaction2 := cashier checkout: anotherCart for: card currentDate: currentDate.	self assert: transaction2 price equals: anotherCart price.	self assert: debitAmount equals: defaultCart price + transaction2 price.	self assert: salesBook first equals: transaction1.	self assert: salesBook second equals: transaction2.	self assert: salesBook size equals: 2.	originalCatalogue := self instanceDefaultCatalogue.	self assert: (originalCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 11.	self assert: (originalCatalogue stock: 2) equals: (defaultCatalogue stock: 2) + 1! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:07'!test08checkoutWithStolenCardFails	| currentDate card |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | CreditCardStolenException new signal ].	self should: [ cashier checkout: defaultCart for: card currentDate: currentDate ] raise: CreditCardStolenException.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 16:58'!test02checkoutNotEnoughStock	defaultCart add: 444.	mp debitBehavior: [ :anAmount :aCreditCard | self fail ].	self should: [ cashier checkout: defaultCart for: nil currentDate: nil ] raise: OutOfStockException.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 10:57'!test04checkoutAddsToSaleBookAndUpdatesStock	| currentDate transaction card debitAmount |	defaultCart add: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := cashier checkout: defaultCart for: card currentDate: currentDate.	self assert: debitAmount equals: defaultCart price.	self assert: transaction price equals: debitAmount.	self assert: salesBook first equals: transaction.	self assert: salesBook size equals: 1.	self assert: (self instanceDefaultCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 1! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:04'!setUp	salesBook := OrderedCollection new.	defaultCatalogue := self instanceDefaultCatalogue.	defaultCart := Cart withCatalogue: defaultCatalogue.	mp := MerchantProcessorSimulator new .	cashier := Cashier processor: mp salesBook: salesBook .! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 16:58'!test01checkoutEmpty	mp debitBehavior: [ :anAmount :aCreditCard | self fail ].	self should: [ cashier checkout: defaultCart for: nil currentDate: nil ] raise: CartEmptyException.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !Object subclass: #CashierTransaction	instanceVariableNames: 'cart payment'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CashierTransaction methodsFor: 'accessing' stamp: 'JulianBayardo 11/6/2017 10:59'!card	^ payment card! !!CashierTransaction methodsFor: 'accessing' stamp: 'DamianFurman 11/6/2017 15:40'!addtoPurchases: somePurchases	| oldQuantity |	self cart list do: [ :each | 		oldQuantity := somePurchases list at: (each key) ifAbsent: [ oldQuantity := 0 ] .		somePurchases addPurchase: (each key)  quantity: (oldQuantity + each value).		] .	somePurchases addToTotalPrice: cart price.! !!CashierTransaction methodsFor: 'accessing' stamp: 'JulianBayardo 11/6/2017 10:58'!price	^ payment price! !!CashierTransaction methodsFor: 'initialization' stamp: 'JulianBayardo 11/6/2017 10:56'!initializeCart: aCart payment: aMerchantProcessorTransaction 	cart := aCart.	payment := aMerchantProcessorTransaction.! !!CashierTransaction methodsFor: 'initialization' stamp: 'JulianBayardo 11/6/2017 10:57'!hash	^ self payment hash.! !!CashierTransaction methodsFor: 'initialization' stamp: 'JulianBayardo 11/6/2017 10:57'!= anObject	^ self payment = anObject payment.! !!CashierTransaction methodsFor: 'initialization' stamp: 'JulianBayardo 11/6/2017 10:56'!cart	^ cart.! !!CashierTransaction methodsFor: 'initialization' stamp: 'JulianBayardo 11/6/2017 10:57'!payment	^ payment! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CashierTransaction class	instanceVariableNames: ''!!CashierTransaction class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/6/2017 10:55'!cart: aCart payment: aMerchantProcessorTransaction 	^ super new initializeCart: aCart payment: aMerchantProcessorTransaction .! !Object subclass: #Clock	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Clock methodsFor: 'initialization' stamp: 'JulianBayardo 11/6/2017 17:44'!now	self subclassResponsibility  .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Clock class	instanceVariableNames: ''!!Clock class methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 13:33'!initialize	^self new initialize .! !Clock subclass: #ClockSimulator	instanceVariableNames: 'timeoutBehaviour currentTime'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!ClockSimulator methodsFor: 'accessing' stamp: 'JulianBayardo 11/6/2017 17:44'!now	^currentTime ifNil: [ ^	TimeOfDay hours: 0 minutes: 0 seconds: 0. ]! !!ClockSimulator methodsFor: 'accessing' stamp: 'DamianFurman 11/6/2017 12:08'!setCurrentTime: aTime	currentTime := aTime .! !Object subclass: #CreditCard	instanceVariableNames: 'name number expiration'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CreditCard methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 20:53'!owner: aName number: aNumber expiration: aDate 	name := aName.	number := aNumber.	expiration := aDate.! !!CreditCard methodsFor: '*Aconcagua-Extensions' stamp: 'LosPibes 10/30/2017 21:03'!hasExpired: aMonthOfYear	^ self expiration < aMonthOfYear.! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:15'!number	^ number.! !!CreditCard methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:05'!hash	^ number hash! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:15'!expiration	^ expiration! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:14'!owner	^ name! !!CreditCard methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:05'!= aCreditCard	^ number = aCreditCard number! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CreditCard class	instanceVariableNames: ''!!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 20:53'!owner: aName number: aNumber expiration: aDate 	^ super new owner: aName number: aNumber expiration: aDate.! !Exception subclass: #CreditCardExpiredException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardNotEnoughFundsException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardStolenException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardUnknownException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #ItemUnknownException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #MerchantProcessor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!MerchantProcessor methodsFor: 'accessing' stamp: 'JulianBayardo 11/6/2017 10:39'!debit: anAmount into: aCard	self subclassResponsibility ! !MerchantProcessor subclass: #MerchantProcessorSimulator	instanceVariableNames: 'debitBehavior transactionId'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!MerchantProcessorSimulator methodsFor: 'testing' stamp: 'DamianFurman 11/5/2017 02:04'!debitBehavior: aBlock	debitBehavior := aBlock.! !!MerchantProcessorSimulator methodsFor: 'initialization' stamp: 'JulianBayardo 11/6/2017 10:46'!initialize	transactionId := 0.! !!MerchantProcessorSimulator methodsFor: 'accessing' stamp: 'JulianBayardo 11/6/2017 10:52'!debit: anAmount into: aCard	transactionId := transactionId + 1.	debitBehavior value: anAmount value: aCard.	^ MerchantProcessorTransaction price: anAmount card: aCard id: transactionId.! !Object subclass: #MerchantProcessorTransaction	instanceVariableNames: 'price card id'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!MerchantProcessorTransaction methodsFor: 'initialization' stamp: 'JulianBayardo 11/6/2017 10:48'!initializePrice: aPrice card: aCard id: aTransactionId	price := aPrice.	card := aCard.	id := aTransactionId! !!MerchantProcessorTransaction methodsFor: 'accessing' stamp: 'JulianBayardo 11/6/2017 10:48'!id	^ id! !!MerchantProcessorTransaction methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 19:28'!card	^ card! !!MerchantProcessorTransaction methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 19:28'!price	^ price! !!MerchantProcessorTransaction methodsFor: 'comparison' stamp: 'JulianBayardo 11/6/2017 10:49'!= anObject	^ self id = anObject id! !!MerchantProcessorTransaction methodsFor: 'comparison' stamp: 'JulianBayardo 11/6/2017 10:49'!hash	^ self id hash! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MerchantProcessorTransaction class	instanceVariableNames: ''!!MerchantProcessorTransaction class methodsFor: 'initialization' stamp: 'JulianBayardo 11/6/2017 10:48'!price: aPrice card: aCard id: aTransactionId	^ super new initializePrice: aPrice card: aCard id: aTransactionId .! !Exception subclass: #OutOfStockException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #PriceInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #PriceTable	instanceVariableNames: 'prices stock'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!PriceTable methodsFor: 'purchase' stamp: 'JulianBayardo 11/5/2017 17:03'!purchase: aCollectionOfPurchases 	aCollectionOfPurchases		do: [ :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			amount timesRepeat: [ stock remove: item ifAbsent: [ ] ]].! !!PriceTable methodsFor: 'purchase' stamp: 'JulianBayardo 11/5/2017 17:44'!hasStockForPurchase: aCollectionOfPurchases	^ aCollectionOfPurchases		noneSatisfy: [ :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			(self stock: item) < amount ]! !!PriceTable methodsFor: 'initialization' stamp: 'LosPibes 10/30/2017 17:27'!initialize	stock := Bag new.	prices := Dictionary new.! !!PriceTable methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 16:03'!add: anItem price: aPrice	^ self add: anItem price: aPrice stock: 0! !!PriceTable methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 17:19'!add: anItem price: aPrice stock: anAmount	aPrice > 0		ifFalse: [ ^ PriceInvalidException new signal ].	(anAmount isKindOf: Integer)		ifFalse: [ ^ AmountInvalidException new signal ].	anAmount >= 0		ifFalse: [ ^ AmountInvalidException new signal ].	stock add: anItem withOccurrences: anAmount.	prices add: (Association key: anItem value: aPrice)! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/5/2017 17:03'!priceMany: aCollectionOfPurchases	^ aCollectionOfPurchases 		inject: 0		into: [ :anAccumulatedPrice :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			anAccumulatedPrice + ((self price: item) * amount) ]! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/5/2017 17:55'!includes: anItem	^ prices includesKey: anItem! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:19'!price: anItem		^ [ prices at: anItem ] on: KeyNotFound do: [ ItemUnknownException new signal. ]! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:19'!stock: anItem	(self includes: anItem) ifFalse: [ ItemUnknownException new signal ].	^ stock occurrencesOf: anItem! !!PriceTable methodsFor: 'testing' stamp: 'LosPibes 10/30/2017 19:47'!stock	^ stock! !TestCase subclass: #PriceTableTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:09'!test01emptyCanNotPrice	| table |	table := PriceTable new.	self assert: (table includes: 2) equals: false.	self should: [ table price: 2 ] raise: ItemUnknownException.	self should: [ table stock: 2 ] raise: ItemUnknownException! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:47'!test06checkStockMultiple	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2).	purchase add: (Association key: 2 value: 1).	self assert: (table hasStockForPurchase: purchase) equals: true.	self assert: (table priceMany: purchase) equals: 33.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:51'!test10purchaseManyUpdatesStock	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2).	purchase add: (Association key: 2 value: 1).	table purchase: purchase.	self assert: (table stock: 1) equals: 18.	self assert: (table price: 1) equals: 10.	self assert: (table stock: 2) equals: 1.	self assert: (table price: 2) equals: 13.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:46'!test04checkStockEmpty	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	self assert: (table hasStockForPurchase: purchase) equals: true.	self assert: (table priceMany: purchase) equals: 0! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:36'!test03addMultipleTimes	| table |	table := PriceTable new.	table add: 2 price: 5 stock: 2.	table add: 2 price: 10 stock: 1.	self assert: (table includes: 2) equals: true.	self assert: (table price: 2) equals: 10.	self assert: (table stock: 2) equals: 3.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:22'!test02singlePrice	| table |	table := PriceTable new.	table add: 2 price: 5 stock: 3.	self assert: (table includes: 2) equals: true.	self assert: (table price: 2) equals: 5.	self assert: (table stock: 2) equals: 3.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:46'!test05checkStockSingle	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 1).	self assert: (table hasStockForPurchase: purchase) equals: true.	self assert: (table priceMany: purchase) equals: 10! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:52'!test11purchaseUnknownDoesNotFail	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2).	purchase add: (Association key: 231311 value: 1).	table purchase: purchase.	self assert: (table stock: 1) equals: 18.	self assert: (table price: 1) equals: 10.	self assert: (table includes: 231311) equals: false.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:57'!test08checkStockUnknownFails	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 4333 value: 2).	self should: [ table hasStockForPurchase: purchase ] raise: ItemUnknownException.	self should: [ table priceMany: purchase ] raise: ItemUnknownException.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:53'!test12purchaseOverStockIsOptimistic	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2222).	table purchase: purchase.	self assert: (table stock: 1) equals: 0.	self assert: (table price: 1) equals: 10.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:47'!test07checkStockSingleMultipleUnits	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2).	self assert: (table hasStockForPurchase: purchase) equals: true.	self assert: (table priceMany: purchase) equals: 20.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:50'!test09purchaseSingleUpdatesStock	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2).	table purchase: purchase.	self assert: (table stock: 1) equals: 18.	self assert: (table price: 1) equals: 10.! !!PriceTableTests methodsFor: 'data' stamp: 'JulianBayardo 11/5/2017 17:08'!instanceDefaultCatalogue	| catalogue |	catalogue := PriceTable new.	catalogue add: 1 price: 10 stock: 20.	catalogue add: 2 price: 13 stock: 2.	catalogue add: 231 price: 23 stock: 4.	catalogue add: 321 price: 433 stock: 4.	catalogue add: 444 price: 111 stock: 0.	^ catalogue! !Object subclass: #Purchases	instanceVariableNames: 'list totalPrice'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Purchases methodsFor: 'initialization' stamp: 'DamianFurman 11/6/2017 15:13'!addPurchase: anIsbn quantity: aQuantity	list at: anIsbn put: aQuantity .! !!Purchases methodsFor: 'initialization' stamp: 'DamianFurman 11/6/2017 15:41'!addToTotalPrice: anAmount	totalPrice := (totalPrice + anAmount) .! !!Purchases methodsFor: 'initialization' stamp: 'DamianFurman 11/6/2017 14:58'!list	^list.! !!Purchases methodsFor: 'initialization' stamp: 'DamianFurman 11/6/2017 14:58'!totalPrice	^totalPrice .! !!Purchases methodsFor: 'initialization' stamp: 'DamianFurman 11/6/2017 14:58'!initialize	list := Dictionary new.	totalPrice := 0.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Purchases class	instanceVariableNames: ''!!Purchases class methodsFor: 'initialization' stamp: 'DamianFurman 11/6/2017 15:08'!initialize	^self new initialize .! !Object subclass: #RESTInterface	instanceVariableNames: 'users catalog indexOfCarts indexCounter cashier mp transactions usersOfCarts timer cartTimes'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!RESTInterface methodsFor: 'authentication' stamp: 'JulianBayardo 11/6/2017 17:54'!authenticate: aUser pass: aPass	| pass |	pass := users at: aUser ifAbsent: [ ^false.] .	(pass = aPass) ifFalse: [ ^false. ] .	^true! !!RESTInterface methodsFor: 'cart manipulation' stamp: 'JulianBayardo 11/6/2017 17:57'!createCartFor: aUser withPass: aPass	| id |	(self authenticate: aUser pass: aPass )		ifTrue: [ 			transactions at: aUser ifAbsent: [ transactions at: aUser put: OrderedCollection new ] .			id := self referenceCart: (Cart withCatalogue: catalog) forUser: aUser .			self updateLastOperation: id.			^ id.			] .	^UserInvalidException new signal .! !!RESTInterface methodsFor: 'cart manipulation' stamp: 'JulianBayardo 11/6/2017 17:57'!addToCart: id bookIsbn: anISBN quantity: aQuantity	| cart |	cart := (self findCart: id) .	(self isTimedOut: id) ifFalse: [ CartTimeOutException new signal ] .	cart add: anISBN amount: aQuantity .	self updateLastOperation: (usersOfCarts at: id) .! !!RESTInterface methodsFor: 'cart manipulation' stamp: 'JulianBayardo 11/6/2017 17:57'!listCart: anId	| cart |	cart := indexOfCarts at: anId ifAbsent: [^CartInvalidException new signal .] .	(self isTimedOut: anId) ifFalse: [ CartTimeOutException new signal ] .	self updateLastOperation: (usersOfCarts at: anId) .	^ cart list .! !!RESTInterface methodsFor: 'cart manipulation' stamp: 'JulianBayardo 11/6/2017 17:59'!referenceCart: aCart forUser: anUser	| id |	indexCounter := indexCounter + 1.	id := indexCounter.	indexOfCarts at: id put: aCart.	usersOfCarts at: id put: anUser.	^ id! !!RESTInterface methodsFor: 'cart manipulation' stamp: 'JulianBayardo 11/6/2017 17:57'!updateLastOperation: aCartId	cartTimes at: aCartId put: timer now.! !!RESTInterface methodsFor: 'cart manipulation' stamp: 'JulianBayardo 11/6/2017 17:56'!isTimedOut: aCartId	^ (timer now < ((cartTimes at: aCartId) next: (TimeUnits minute with: 30))).! !!RESTInterface methodsFor: 'cart manipulation' stamp: 'JulianBayardo 11/5/2017 16:55'!findCart: anId	^indexOfCarts at: anId ifAbsent: [^CartInvalidException new signal .] .! !!RESTInterface methodsFor: 'initialization' stamp: 'JulianBayardo 11/6/2017 17:53'!initializeUsers: aDictionary catalog: aCatalog paymentProcessor: anMP clock: aTimer	users := aDictionary.	catalog := aCatalog.	indexOfCarts := Dictionary new.	indexCounter := 0.	mp := anMP.	cashier := Cashier processor: mp salesBook: OrderedCollection new.	transactions := Dictionary new.	usersOfCarts := Dictionary new.	timer := aTimer.	cartTimes := Dictionary new! !!RESTInterface methodsFor: 'user manipulation' stamp: 'JulianBayardo 11/6/2017 17:54'!listOfTransactionsFor: aUser withPass: aPass	(self authenticate: aUser pass: aPass )		ifTrue: [ ^self transactionsFor: aUser ] .	^UserInvalidException new signal .! !!RESTInterface methodsFor: 'user manipulation' stamp: 'JulianBayardo 11/6/2017 17:54'!listOfPurchasesFor: aUser withPass: aPass	| purchases |	(self authenticate: aUser pass: aPass )		ifFalse: [	^UserInvalidException new signal . ] .	transactions := self transactionsFor: aUser .	purchases := Purchases initialize .	transactions do: [ :each | each addtoPurchases: purchases] .	^purchases .! !!RESTInterface methodsFor: 'user manipulation' stamp: 'DamianFurman 11/5/2017 11:22'!transactionsFor: aUser	^(transactions at: aUser)! !!RESTInterface methodsFor: 'checkout' stamp: 'JulianBayardo 11/6/2017 17:56'!checkout: aCartId card: aCreditCard date: aCurrentDate	| cart transaction |	cart := self findCart: aCartId .	(self isTimedOut: aCartId ) ifFalse: [ ^CartTimeOutException new signal] .	transaction := cashier checkout: cart for: aCreditCard currentDate: aCurrentDate .	(transactions at: (usersOfCarts at: aCartId)) add: transaction .	^ transaction .! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RESTInterface class	instanceVariableNames: ''!!RESTInterface class methodsFor: 'initialization' stamp: 'JulianBayardo 11/6/2017 17:53'!users: aDictionary catalog: aCatalog paymentProcessor: aPaymentProcessor clock: aClock	^ self new		initializeUsers: aDictionary		catalog: aCatalog		paymentProcessor: aPaymentProcessor		clock: aClock! !TestCase subclass: #RESTInterfaceTests	instanceVariableNames: 'restInterface catalog mp timer'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 17:50'!test13CantReferenceUsersPurchaseHistoryForInvalidPass	| id currentDate creditCard debitAmount transaction transactionList id2 id3 transaction2 |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id2 := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id3 := restInterface createCartFor: 'AnotherValidUser' withPass: 'AnotherValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	restInterface addToCart: id2 bookIsbn: 7  quantity: 3 .	restInterface addToCart: id3 bookIsbn: 1  quantity: 4 . 	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := restInterface checkout: id card: creditCard date: currentDate .	transaction2 := restInterface checkout: id3 card: creditCard date: currentDate .	self should: [transactionList := restInterface listOfTransactionsFor: 'ValidUser' withPass: 'InvalidPass' .] raise: UserInvalidException .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 17:50'!test12CanReferenceUsersPurchaseHistory	| id currentDate creditCard debitAmount transaction transactionList id2 id3 transaction2 transactionList2 |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id2 := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id3 := restInterface createCartFor: 'AnotherValidUser' withPass: 'AnotherValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	restInterface addToCart: id2 bookIsbn: 7  quantity: 3 .	restInterface addToCart: id3 bookIsbn: 1  quantity: 4 . 	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := restInterface checkout: id card: creditCard date: currentDate .	transaction2 := restInterface checkout: id3 card: creditCard date: currentDate .	transactionList := restInterface listOfTransactionsFor: 'ValidUser' withPass: 'ValidPass' .	transactionList2 := restInterface listOfTransactionsFor: 'AnotherValidUser' withPass: 'AnotherValidPass' .	self assert: (transactionList includes: transaction) .	self assert: (transactionList includes: transaction2) not .	self assert: (transactionList size) equals: 1.	self assert: (transactionList2 includes: transaction2) .	self assert: (transactionList2 includes: transaction) not .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 17:50'!test16CantCheckoutFromExpiredCart	| id currentDate creditCard debitAmount |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2.	currentDate := January first , 2018.	creditCard := CreditCard		owner: 'ValidUser'		number: 1234567890123456		expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	timer setCurrentTime: (TimeOfDay hours: 0 minutes: 31 seconds: 15).	self		should: [ restInterface checkout: id card: creditCard date: currentDate ]		raise: CartTimeOutException! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:03'!test05CanCreateCartAndGetId	| id cart |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	cart := restInterface findCart: id .	self assert: (cart list isEmpty) .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 17:50'!test11CantCheckoutWithInvalidCreditCart	| id creditCard currentDate transaction |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate previous: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | self fail ].	self should: [transaction := restInterface checkout: id card: creditCard date: currentDate .] raise: CreditCardExpiredException .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 17:50'!test12BisCanReferenceUsersPurchaseHistoryWithMultipleCarts	| id currentDate creditCard debitAmount transaction transactionList id2 id3 transaction2 transactionList2 transaction3 |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id2 := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id3 := restInterface createCartFor: 'AnotherValidUser' withPass: 'AnotherValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	restInterface addToCart: id2 bookIsbn: 7  quantity: 3 .	restInterface addToCart: id3 bookIsbn: 1  quantity: 4 . 	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := restInterface checkout: id card: creditCard date: currentDate .	transaction2 := restInterface checkout: id2 card: creditCard date: currentDate .	transaction3 := restInterface checkout: id3 card: creditCard date: currentDate .	transactionList := restInterface listOfTransactionsFor: 'ValidUser' withPass: 'ValidPass' .	transactionList2 := restInterface listOfTransactionsFor: 'AnotherValidUser' withPass: 'AnotherValidPass' .	self assert: (transactionList includes: transaction) .	self assert: (transactionList includes: transaction2) .	self assert: (transactionList size) equals: 2.	self assert: (transactionList2 includes: transaction3) .	self assert: (transactionList2 includes: transaction) not .	self assert: (transactionList2 includes: transaction2) not .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 17:54'!test03ValidUserValidates		self assert: (restInterface authenticate: 'ValidUser' pass: 'ValidPass' ) .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 16:55'!test09CantListToInvalidCart	| id |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	self should: [restInterface listCart: (id + 10) .] raise: CartInvalidException .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 11:21'!test04CanIndexCartAndReferenceIt	| cart book id cart2 book7 |	"Originally this test checked if it was possible to reference any cart, but now it's not possible to reference it whitout being asociated to an User so it only checks that is possible to index carts created throug the rest interface"	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	cart := restInterface findCart: id .	book := 1 .	cart add: book amount: 3.	book7 := 7 .	cart add: book7 .	id := restInterface referenceCart: cart forUser: 'ValidUser' .	cart2 := restInterface findCart: id .	self assert: (cart2 amount: book) equals: 3 .	self assert: (cart2 amount: book7) equals: 1 .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:20'!test07CanListValidCart	| id list |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	list := restInterface listCart: id .	self assert: (list includes: (Association key: 1 value: 2) ) .	self assert: (list includes: (Association key: 7 value: 1) ) .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 16:55'!test08CantAddToInvalidCart	| id |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	self should: [restInterface addToCart: (id + 10) bookIsbn: 1 quantity: 2 .] raise: CartInvalidException .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 17:54'!test02ValidUserInvalidPassDontValidate	self assert: (restInterface authenticate: 'ValidUser' pass: '123456' ) not .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/6/2017 13:21'!test15CantListFromExpiredCart	| id |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	timer setCurrentTime: (TimeOfDay hours: 0 minutes: 31 seconds: 15).	self should: [restInterface listCart: id.] raise: CartTimeOutException.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:20'!test06CanAddToValidCart	| id cart |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	cart := restInterface findCart: id .	self assert: (cart amount: 1) equals: 2 .	self assert: (cart amount: 7) equals: 1! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 17:50'!test10CanCheckoutWithValidCartAndCreditCart	| id creditCard currentDate debitAmount transaction |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := restInterface checkout: id card: creditCard date: currentDate .	self assert: transaction cart equals: (restInterface findCart: id) .	self assert: transaction card equals: creditCard.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/6/2017 13:21'!test14CantAddToExpiredCart	| id |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	timer setCurrentTime: (TimeOfDay hours: 0 minutes: 31 seconds: 15) .	self should: [restInterface addToCart: id bookIsbn: 1 quantity: 2 .] raise: CartTimeOutException.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 17:54'!test01invalidUserDontValidate	self assert: (restInterface authenticate: 'Pepe' pass: '123456' ) not .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 17:52'!setUp	| init book1 book7 |	init := Dictionary new .	init at: 'ValidUser' put: 'ValidPass' .	init at: 'AnotherValidUser' put: 'AnotherValidPass' .	catalog := PriceTable new.	book1 := 1 .	catalog add: book1 price: 10 stock: 7 .	book7 := 7 .	catalog add: book7 price: 8 stock: 9.	mp := MerchantProcessorSimulator new .	timer := ClockSimulator initialize .	restInterface := RESTInterface users: init catalog: catalog paymentProcessor: mp clock: timer.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/6/2017 17:50'!test17CanGetListOfPurchases	| id currentDate creditCard debitAmount transaction transactionList id2 id3 transaction2 transactionList2 transaction3 purchases  |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id2 := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id3 := restInterface createCartFor: 'AnotherValidUser' withPass: 'AnotherValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	restInterface addToCart: id2 bookIsbn: 7  quantity: 3 .	restInterface addToCart: id3 bookIsbn: 1  quantity: 4 . 	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := restInterface checkout: id card: creditCard date: currentDate .	transaction2 := restInterface checkout: id2 card: creditCard date: currentDate .	transaction3 := restInterface checkout: id3 card: creditCard date: currentDate .	transactionList := restInterface listOfTransactionsFor: 'ValidUser' withPass: 'ValidPass' .	transactionList2 := restInterface listOfTransactionsFor: 'AnotherValidUser' withPass: 'AnotherValidPass' .	purchases := restInterface listOfPurchasesFor: 'ValidUser' withPass: 'ValidPass' .	self assert: (purchases list at: 7) equals: 4 .	self assert: (purchases list at: 1) equals: 2 .	self assert: purchases totalPrice equals: 52.! !Exception subclass: #UserInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Clock initialize!Purchases initialize!