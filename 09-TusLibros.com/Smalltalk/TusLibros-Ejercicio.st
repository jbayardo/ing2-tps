Exception subclass: #AmountInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #Cart	instanceVariableNames: 'catalogue items'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Cart methodsFor: 'initialization' stamp: 'LosPibes 10/30/2017 20:30'!initialize	items := Bag new! !!Cart methodsFor: 'initialization' stamp: 'LosPibes 10/26/2017 20:51'!initializeCatalogue: aCatalogue 	catalogue := aCatalogue.! !!Cart methodsFor: 'purchase' stamp: 'JulianBayardo 11/5/2017 17:44'!isValidPurchase	^ catalogue hasStockForPurchase: (self list).! !!Cart methodsFor: 'purchase' stamp: 'JulianBayardo 11/5/2017 17:04'!purchase	^ catalogue purchase: (self list)! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:30'!size	^ items size! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:30'!list	| aList |	aList := Set new.	items		doWithOccurrences: [ :anItem :occurrences | aList add: (Association key: anItem value: occurrences) ].	^ aList! !!Cart methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 20:31'!amount: anItem	^ items occurrencesOf: anItem! !!Cart methodsFor: 'accessing' stamp: 'JulianBayardo 11/5/2017 17:03'!price	^ catalogue priceMany: self list! !!Cart methodsFor: 'accessing' stamp: 'JulianBayardo 10/31/2017 17:35'!isEmpty	^ items isEmpty.! !!Cart methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 17:19'!add: anItem amount: anAmount	(catalogue includes: anItem)		ifFalse: [ ^ ItemUnknownException new signal ].	(anAmount isKindOf: Integer)		ifFalse: [ ^ AmountInvalidException new signal ].	anAmount > 0		ifFalse: [ ^ AmountInvalidException new signal ].	items add: anItem withOccurrences: anAmount.	^ self! !!Cart methodsFor: 'adding' stamp: 'LosPibes 10/30/2017 20:29'!add: anItem	^ self add: anItem amount: 1.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cart class	instanceVariableNames: ''!!Cart class methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/26/2017 20:59'!withCatalogue: aCatalogue	^ super new initializeCatalogue: aCatalogue! !Exception subclass: #CartEmptyException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CartInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!TestCase subclass: #CartTests	instanceVariableNames: 'defaultCart'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:06'!test08listOfMultipleItemsHasAccurateCounts	| book list computedList book2 |	book := 231.	defaultCart add: book amount: 2.	book2 := 321.	defaultCart add: book2.	list := Set new.	list add: (Association key: 231 value: 2).	list add: (Association key: 321 value: 1).	computedList := defaultCart list.	self assert: computedList size equals: 2.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:06'!test07listOfSingleItemTwiceHasAccurateCounts	| book list computedList |	book := 231.	defaultCart add: book amount: 2.	list := Set new.	list add: (Association key: 231 value: 2).	computedList := defaultCart list.	self assert: computedList size equals: 1.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:27'!test00newCarIsEmpty	self assert: defaultCart isEmpty! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test03canHoldMultipleItems	| book book2 |	book := 1.	book2 := 2.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: (defaultCart amount: book2) equals: 0.	defaultCart add: book2.	self assert: (defaultCart amount: book2) equals: 1.	self assert: defaultCart size equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test09itemMustBeInCatalogue	| book catalogue book2 cart |	book := 2312.	book2 := 23111.	catalogue := Set new.	catalogue add: book.	cart := Cart withCatalogue: catalogue.	self should: [ cart add: book2 ] raise: ItemUnknownException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:26'!instanceDefaultCatalogue	| catalogue |	catalogue := PriceTable new.	catalogue add: 1 price: 10 stock: 20.	catalogue add: 2 price: 13 stock: 2.	catalogue add: 231 price: 23 stock: 4.	catalogue add: 321 price: 433 stock: 4.	catalogue add: 444 price: 111 stock: 0.	^ catalogue! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:06'!test06listOfSingleItemHasAccurateCounts	| book list computedList |	book := 231.	defaultCart add: book.	list := Set new.	list add: (Association key: 231 value: 1).	computedList := defaultCart list.	self assert: computedList size equals: 1.	self assert: computedList equals: list! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:29'!test04canSearchByBookAlias	| book book2 |	book := 1.	book2 := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: (defaultCart amount: book2) equals: 1.	defaultCart add: book2.	self assert: (defaultCart amount: book) equals: 2.	self assert: (defaultCart amount: book2) equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test11amountsMustBeGreaterThanZero	| book |	book := 231.	self should: [ defaultCart add: book amount: 0 ] raise: AmountInvalidException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:01'!test05listOfItemsOfEmptyCartIsEmpty	self assert: defaultCart list size equals: 0! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 17:19'!test10amountsMustBeIntegers	| book |	book := 231.	self should: [ defaultCart add: book amount: 1 / 3 ] raise: AmountInvalidException! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test02itemCanBeAddedMultipleTimes	| book |	book := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book amount: 2.	self assert: (defaultCart amount: book) equals: 2.	self assert: defaultCart size equals: 2! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 11/1/2017 16:00'!test01itemIsPresentAfterAdding	| book |	book := 1.	self assert: (defaultCart amount: book) equals: 0.	defaultCart add: book.	self assert: (defaultCart amount: book) equals: 1.	self assert: defaultCart size equals: 1.! !!CartTests methodsFor: 'tests' stamp: 'JulianBayardo 10/31/2017 16:27'!setUp	defaultCart := Cart withCatalogue: self instanceDefaultCatalogue.! !Exception subclass: #CartTimeOutException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #Cashier	instanceVariableNames: 'paymentProcessor salesBook'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Cashier methodsFor: 'validation' stamp: 'JulianBayardo 11/1/2017 15:58'!validateCard: aCard currentMonthOfYear: aMonthOfYear	(aCard hasExpired: aMonthOfYear)		ifTrue: [ CreditCardExpiredException new signal ].! !!Cashier methodsFor: 'validation' stamp: 'JulianBayardo 11/5/2017 17:04'!validateCart: aCart	aCart isEmpty		ifTrue: [ CartEmptyException new signal ].	aCart isValidPurchase ifFalse: [ OutOfStockException new signal. ].! !!Cashier methodsFor: 'purchase' stamp: 'JulianBayardo 11/5/2017 17:04'!checkout: aCart for: aCard currentDate: aTimestamp	| price transaction |	self validateCart: aCart.	self validateCard: aCard currentMonthOfYear: aTimestamp monthOfYear.	price := aCart price.	paymentProcessor debit: price into: aCard.	transaction := Transaction cart: aCart price: price card: aCard.	salesBook add: transaction.	aCart purchase.	^ transaction! !!Cashier methodsFor: 'initialization' stamp: 'JulianBayardo 11/1/2017 17:13'!processor: aPaymentProcessor salesBook: aSalesBook	paymentProcessor := aPaymentProcessor .	salesBook := aSalesBook.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cashier class	instanceVariableNames: ''!!Cashier class methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/1/2017 17:13'!processor: aPaymentProcessor salesBook: aSalesBook	^ Cashier new processor: aPaymentProcessor salesBook: aSalesBook.! !TestCase subclass: #CashierTests	instanceVariableNames: 'salesBook defaultCatalogue defaultCart cashier mp'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CashierTests methodsFor: 'data' stamp: 'LosPibes 10/30/2017 21:20'!instanceNonExpiredCreditCard: currentDate	^ CreditCard		owner: 'Roberto Bolanos'		number: 1234567891234567		expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear! !!CashierTests methodsFor: 'data' stamp: 'JulianBayardo 10/31/2017 16:26'!instanceDefaultCatalogue	| catalogue |	catalogue := PriceTable new.	catalogue add: 1 price: 10 stock: 20.	catalogue add: 2 price: 13 stock: 2.	catalogue add: 231 price: 23 stock: 4.	catalogue add: 321 price: 433 stock: 4.	catalogue add: 444 price: 111 stock: 0.	^ catalogue! !!CashierTests methodsFor: 'data' stamp: 'LosPibes 10/30/2017 21:05'!instanceExpiredCreditCard: currentDate	^ CreditCard		owner: 'Roberto Bolanos'		number: 1234567891234567		expiration: (currentDate previous: (TimeUnits month with: 1)) monthOfYear! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:06'!test05checkoutMultipleAddsToSaleBookAndUpdatesStock	| currentDate transaction card originalCatalogue debitAmount |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := cashier checkout: defaultCart for: card currentDate: currentDate.	self assert: transaction cart equals: defaultCart.	self assert: transaction price equals: defaultCart price.	self assert: transaction card equals: card.	self assert: debitAmount equals: transaction price.	self assert: salesBook first equals: transaction.	self assert: salesBook size equals: 1.	originalCatalogue := self instanceDefaultCatalogue.	self assert: (originalCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 5.	self assert: (originalCatalogue stock: 2) equals: (defaultCatalogue stock: 2) + 1! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:07'!test07checkoutWithFakeCardFails	| currentDate card |	defaultCart add: 1 amount: 5.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | CreditCardUnknownException new signal ].	self should: [ cashier checkout: defaultCart for: card currentDate: currentDate ] raise: CreditCardUnknownException.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 16:58'!test03checkoutExpiredCard	| currentDate |	defaultCart add: 1.	currentDate := January first , 2004.	mp debitBehavior: [ :anAmount :aCreditCard | self fail ].	self should: [ cashier checkout: defaultCart for: (self instanceExpiredCreditCard: currentDate) currentDate: currentDate ] raise: CreditCardExpiredException.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:07'!test09checkoutNotEnoughFundsFails	| currentDate card |	defaultCart add: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | CreditCardNotEnoughFundsException new signal ].	self should: [ cashier checkout: defaultCart for: card currentDate: currentDate ] raise: CreditCardNotEnoughFundsException.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:06'!test06checkoutManyAddsToSalesBookAndUpdatesAppropriately	| currentDate transaction1 card originalCatalogue anotherCart transaction2 debitAmount |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	anotherCart := Cart withCatalogue: defaultCatalogue.	anotherCart add: 1 amount: 6.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	debitAmount := 0.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := debitAmount + anAmount ].	transaction1 := cashier checkout: defaultCart for: card currentDate: currentDate.	self assert: debitAmount equals: transaction1 price.	transaction2 := cashier checkout: anotherCart for: card currentDate: currentDate.	self assert: debitAmount equals: transaction1 price + transaction2 price.	self assert: salesBook first equals: transaction1.	self assert: salesBook second equals: transaction2.	self assert: salesBook size equals: 2.	originalCatalogue := self instanceDefaultCatalogue.	self assert: (originalCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 11.	self assert: (originalCatalogue stock: 2) equals: (defaultCatalogue stock: 2) + 1! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:07'!test08checkoutWithStolenCardFails	| currentDate card |	defaultCart add: 1 amount: 5.	defaultCart add: 2 amount: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | CreditCardStolenException new signal ].	self should: [ cashier checkout: defaultCart for: card currentDate: currentDate ] raise: CreditCardStolenException.	self assert: salesBook isEmpty.	self assert: self instanceDefaultCatalogue stock equals: defaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 16:58'!test02checkoutNotEnoughStock	defaultCart add: 444.	mp debitBehavior: [ :anAmount :aCreditCard | self fail ].	self should: [ cashier checkout: defaultCart for: nil currentDate: nil ] raise: OutOfStockException.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:05'!test04checkoutAddsToSaleBookAndUpdatesStock	| currentDate transaction card debitAmount |	defaultCart add: 1.	currentDate := January first , 2004.	card := self instanceNonExpiredCreditCard: currentDate.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := cashier checkout: defaultCart for: card currentDate: currentDate.	self assert: transaction cart equals: defaultCart.	self assert: transaction price equals: defaultCart price.	self assert: transaction card equals: card.	self assert: debitAmount equals: transaction  price.	self assert: salesBook first equals: transaction.	self assert: salesBook size equals: 1.	self assert: (self instanceDefaultCatalogue stock: 1) equals: (defaultCatalogue stock: 1) + 1! !!CashierTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:04'!setUp	salesBook := OrderedCollection new.	defaultCatalogue := self instanceDefaultCatalogue.	defaultCart := Cart withCatalogue: defaultCatalogue.	mp := MerchantProcessorSimulator new .	cashier := Cashier processor: mp salesBook: salesBook .! !!CashierTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 16:58'!test01checkoutEmpty	mp debitBehavior: [ :anAmount :aCreditCard | self fail ].	self should: [ cashier checkout: defaultCart for: nil currentDate: nil ] raise: CartEmptyException.	self assert: salesBook isEmpty.	self assert: defaultCatalogue stock equals: self instanceDefaultCatalogue stock! !Object subclass: #CreditCard	instanceVariableNames: 'name number expiration'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!CreditCard methodsFor: '*Aconcagua-Extensions' stamp: 'LosPibes 10/30/2017 21:03'!hasExpired: aMonthOfYear	^ self expiration < aMonthOfYear.! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:15'!number	^ number.! !!CreditCard methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:05'!hash	^ number hash! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:15'!expiration	^ expiration! !!CreditCard methodsFor: 'accessing' stamp: 'LosPibes 10/30/2017 21:14'!owner	^ name! !!CreditCard methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:05'!= aCreditCard	^ number = aCreditCard number! !!CreditCard methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 20:53'!owner: aName number: aNumber expiration: aDate 	name := aName.	number := aNumber.	expiration := aDate.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CreditCard class	instanceVariableNames: ''!!CreditCard class methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 20:53'!owner: aName number: aNumber expiration: aDate 	^ super new owner: aName number: aNumber expiration: aDate.! !Exception subclass: #CreditCardExpiredException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardNotEnoughFundsException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardStolenException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #CreditCardUnknownException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #ItemUnknownException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #MerchantProcessor	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!MerchantProcessor methodsFor: 'accessing' stamp: 'JulianBayardo 11/2/2017 17:44'!debit: anAmount into: aCard	" aCard es un objeto CreditCard"	| owner number expiration |	owner := self formatOwner: aCard.	number := self formatNumber: aCard.	expiration := self formatExpiration: aCard.! !MerchantProcessor subclass: #MerchantProcessorSimulator	instanceVariableNames: 'debitBehavior'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!MerchantProcessorSimulator methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 01:58'!debit: anAmount into: aCreditCard	^ debitBehavior value: anAmount value: aCreditCard ! !!MerchantProcessorSimulator methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 02:04'!debitBehavior: aBlock	debitBehavior := aBlock.! !Exception subclass: #OutOfStockException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Exception subclass: #PriceInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Object subclass: #PriceTable	instanceVariableNames: 'prices stock'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!PriceTable methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 16:03'!add: anItem price: aPrice	^ self add: anItem price: aPrice stock: 0! !!PriceTable methodsFor: 'adding' stamp: 'JulianBayardo 11/1/2017 17:19'!add: anItem price: aPrice stock: anAmount	aPrice > 0		ifFalse: [ ^ PriceInvalidException new signal ].	(anAmount isKindOf: Integer)		ifFalse: [ ^ AmountInvalidException new signal ].	anAmount >= 0		ifFalse: [ ^ AmountInvalidException new signal ].	stock add: anItem withOccurrences: anAmount.	prices add: (Association key: anItem value: aPrice)! !!PriceTable methodsFor: 'testing' stamp: 'LosPibes 10/30/2017 19:47'!stock	^ stock! !!PriceTable methodsFor: 'purchase' stamp: 'JulianBayardo 11/5/2017 17:03'!purchase: aCollectionOfPurchases 	aCollectionOfPurchases		do: [ :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			amount timesRepeat: [ stock remove: item ifAbsent: [ ] ]].! !!PriceTable methodsFor: 'purchase' stamp: 'JulianBayardo 11/5/2017 17:44'!hasStockForPurchase: aCollectionOfPurchases	^ aCollectionOfPurchases		noneSatisfy: [ :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			(self stock: item) < amount ]! !!PriceTable methodsFor: 'initialization' stamp: 'LosPibes 10/30/2017 17:27'!initialize	stock := Bag new.	prices := Dictionary new.! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/5/2017 17:55'!includes: anItem	^ prices includesKey: anItem! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/5/2017 17:03'!priceMany: aCollectionOfPurchases	^ aCollectionOfPurchases 		inject: 0		into: [ :anAccumulatedPrice :anItem | 			| item amount |			item := anItem key.			amount := anItem value.			anAccumulatedPrice + ((self price: item) * amount) ]! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:19'!price: anItem		^ [ prices at: anItem ] on: KeyNotFound do: [ ItemUnknownException new signal. ]! !!PriceTable methodsFor: 'accessing' stamp: 'JulianBayardo 11/1/2017 17:19'!stock: anItem	(self includes: anItem) ifFalse: [ ItemUnknownException new signal ].	^ stock occurrencesOf: anItem! !TestCase subclass: #PriceTableTests	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:09'!test01emptyCanNotPrice	| table |	table := PriceTable new.	self assert: (table includes: 2) equals: false.	self should: [ table price: 2 ] raise: ItemUnknownException.	self should: [ table stock: 2 ] raise: ItemUnknownException! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:47'!test06checkStockMultiple	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2).	purchase add: (Association key: 2 value: 1).	self assert: (table hasStockForPurchase: purchase) equals: true.	self assert: (table priceMany: purchase) equals: 33.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:08'!instanceDefaultCatalogue	| catalogue |	catalogue := PriceTable new.	catalogue add: 1 price: 10 stock: 20.	catalogue add: 2 price: 13 stock: 2.	catalogue add: 231 price: 23 stock: 4.	catalogue add: 321 price: 433 stock: 4.	catalogue add: 444 price: 111 stock: 0.	^ catalogue! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:46'!test04checkStockEmpty	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	self assert: (table hasStockForPurchase: purchase) equals: true.	self assert: (table priceMany: purchase) equals: 0! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:36'!test03addMultipleTimes	| table |	table := PriceTable new.	table add: 2 price: 5 stock: 2.	table add: 2 price: 10 stock: 1.	self assert: (table includes: 2) equals: true.	self assert: (table price: 2) equals: 10.	self assert: (table stock: 2) equals: 3.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:22'!test02singlePrice	| table |	table := PriceTable new.	table add: 2 price: 5 stock: 3.	self assert: (table includes: 2) equals: true.	self assert: (table price: 2) equals: 5.	self assert: (table stock: 2) equals: 3.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:46'!test05checkStockSingle	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 1).	self assert: (table hasStockForPurchase: purchase) equals: true.	self assert: (table priceMany: purchase) equals: 10! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:47'!test07checkStockSingleMultipleUnits	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2).	self assert: (table hasStockForPurchase: purchase) equals: true.	self assert: (table priceMany: purchase) equals: 20.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:51'!test10purchaseManyUpdatesStock	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2).	purchase add: (Association key: 2 value: 1).	table purchase: purchase.	self assert: (table stock: 1) equals: 18.	self assert: (table price: 1) equals: 10.	self assert: (table stock: 2) equals: 1.	self assert: (table price: 2) equals: 13.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:52'!test11purchaseUnknownDoesNotFail	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2).	purchase add: (Association key: 231311 value: 1).	table purchase: purchase.	self assert: (table stock: 1) equals: 18.	self assert: (table price: 1) equals: 10.	self assert: (table includes: 231311) equals: false.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:53'!test12purchaseOverStockIsOptimistic	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2222).	table purchase: purchase.	self assert: (table stock: 1) equals: 0.	self assert: (table price: 1) equals: 10.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:57'!test08checkStockUnknownFails	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 4333 value: 2).	self should: [ table hasStockForPurchase: purchase ] raise: ItemUnknownException.	self should: [ table priceMany: purchase ] raise: ItemUnknownException.! !!PriceTableTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:50'!test09purchaseSingleUpdatesStock	| table purchase |	table := self instanceDefaultCatalogue.	purchase := Set new.	purchase add: (Association key: 1 value: 2).	table purchase: purchase.	self assert: (table stock: 1) equals: 18.	self assert: (table price: 1) equals: 10.! !Object subclass: #RESTInterface	instanceVariableNames: 'users catalog indexOfCarts indexCounter cashier mp transactions usersOfCarts timer'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!RESTInterface methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 12:03'!nextIndex	indexCounter := (indexCounter + 1).	^indexCounter.! !!RESTInterface methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 13:32'!initializeWithUsers: aDictionary catalog: aCatalog andMP: anMP	users := aDictionary .	catalog := aCatalog .	indexOfCarts := Dictionary new .	indexCounter := 0 .	mp := anMP.	cashier := Cashier processor: mp salesBook: OrderedCollection new .	transactions := Dictionary new .	usersOfCarts := Dictionary new .	timer := Timer initialize .! !!RESTInterface methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 11:31'!initializeUserVariables: aUser	transactions at: aUser put: OrderedCollection new .! !!RESTInterface methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 14:04'!setTimerSimulator: aBlock	timer := TimerSimulator initialize .	timer timeoutBehaviour: aBlock .! !!RESTInterface methodsFor: 'adding' stamp: 'DamianFurman 11/5/2017 14:11'!addToCart: id bookIsbn: anISBN quantity: aQuantity	| cart |	cart := (self findCart: id) .	(timer checkTimeoutFor: id) ifFalse: [ CartTimeOutException new signal ] .	cart add: anISBN amount: aQuantity .	timer tickFor: (usersOfCarts at: id) .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/5/2017 16:56'!createCartFor: aUser withPass: aPass	| id |	(self validateFor: aUser withPass: aPass )		ifTrue: [ 			transactions at: aUser ifAbsent: [ transactions at: aUser put: OrderedCollection new ] .			id := self referenceCart: (Cart withCatalogue: catalog) forUser: aUser .			timer tickFor: id.			^ id.			] .	^UserInvalidException new signal .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 11:22'!transactionsFor: aUser	^(transactions at: aUser)! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 13:48'!checkout: aCartId withCard: aCreditCard currentDate: aCurrentDate	| cart transaction |	cart := self findCart: aCartId .	(timer checkTimeoutFor: aCartId ) ifFalse: [ ^CartTimeOutException ] .	transaction := cashier checkout: cart for: aCreditCard currentDate: aCurrentDate .	(transactions at: (usersOfCarts at: aCartId)) add: transaction .	^ transaction .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/5/2017 16:55'!listCart: anId	| cart |	cart := indexOfCarts at: anId ifAbsent: [^CartInvalidException new signal .] .	(timer checkTimeoutFor: anId) ifFalse: [ CartTimeOutException new signal ] .	timer tickFor: (usersOfCarts at: anId) .	^ cart list .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 11:42'!referenceCart: aCart forUser: anUser	| id |	id := self nextIndex .	indexOfCarts at: id put: aCart .	usersOfCarts at: id put: anUser .	^id .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/5/2017 16:56'!listPurchasesFor: aUser withPass: aPass	(self validateFor: aUser withPass: aPass )		ifTrue: [ ^self transactionsFor: aUser ] .	^UserInvalidException new signal .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'JulianBayardo 11/5/2017 16:55'!findCart: anId	^indexOfCarts at: anId ifAbsent: [^CartInvalidException new signal .] .! !!RESTInterface methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 00:32'!validateFor: aUser withPass: aPass	| pass |	pass := users at: aUser ifAbsent: [ ^false.] .	(pass = aPass) ifFalse: [ ^false. ] .	^true! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RESTInterface class	instanceVariableNames: ''!!RESTInterface class methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 02:30'!initializeWithUsers: aDictionary catalog: aCatalog andMP: anMP	^ self new initializeWithUsers: aDictionary catalog: aCatalog andMP: anMP.! !TestCase subclass: #RESTInterfaceTests	instanceVariableNames: 'restInterface catalog mp'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 11:51'!test12CanReferenceUsersPurchaseHistory	| id currentDate creditCard debitAmount transaction transactionList id2 id3 transaction2 transactionList2 |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id2 := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id3 := restInterface createCartFor: 'AnotherValidUser' withPass: 'AnotherValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	restInterface addToCart: id2 bookIsbn: 7  quantity: 3 .	restInterface addToCart: id3 bookIsbn: 1  quantity: 4 . 	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := restInterface checkout: id withCard: creditCard currentDate: currentDate .	transaction2 := restInterface checkout: id3 withCard: creditCard currentDate: currentDate .	transactionList := restInterface listPurchasesFor: 'ValidUser' withPass: 'ValidPass' .	transactionList2 := restInterface listPurchasesFor: 'AnotherValidUser' withPass: 'AnotherValidPass' .	self assert: (transactionList includes: transaction) .	self assert: (transactionList includes: transaction2) not .	self assert: (transactionList size) equals: 1.	self assert: (transactionList2 includes: transaction2) .	self assert: (transactionList2 includes: transaction) not .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 14:17'!test15CantListFromExpiredCart	| id |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface setTimerSimulator: [ :anUser | ^false] . "This means that timeout has ocurred"	self should: [restInterface listCart: id.] raise: CartTimeOutException.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 14:19'!test16CantCheckoutFromExpiredCart	| id currentDate creditCard debitAmount |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	restInterface setTimerSimulator: [ :anUser | ^false] . "This means that timeout has ocurred"	self should: [restInterface checkout: id withCard: creditCard currentDate: currentDate .] raise: CartTimeOutException.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 16:55'!test08CantAddToInvalidCart	| id |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	self should: [restInterface addToCart: (id + 10) bookIsbn: 1 quantity: 2 .] raise: CartInvalidException .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 16:55'!test09CantListToInvalidCart	| id |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	self should: [restInterface listCart: (id + 10) .] raise: CartInvalidException .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 17:09'!test01invalidUserDontValidate	self assert: (restInterface validateFor: 'Pepe' withPass: '123456' ) not .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:20'!test07CanListValidCart	| id list |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	list := restInterface listCart: id .	self assert: (list includes: (Association key: 1 value: 2) ) .	self assert: (list includes: (Association key: 7 value: 1) ) .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:00'!test03ValidUserValidates		self assert: (restInterface validateFor: 'ValidUser' withPass: 'ValidPass' ) .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 11:21'!test04CanIndexCartAndReferenceIt	| cart book id cart2 book7 |	"Originally this test checked if it was possible to reference any cart, but now it's not possible to reference it whitout being asociated to an User so it only checks that is possible to index carts created throug the rest interface"	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	cart := restInterface findCart: id .	book := 1 .	cart add: book amount: 3.	book7 := 7 .	cart add: book7 .	id := restInterface referenceCart: cart forUser: 'ValidUser' .	cart2 := restInterface findCart: id .	self assert: (cart2 amount: book) equals: 3 .	self assert: (cart2 amount: book7) equals: 1 .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:20'!test06CanAddToValidCart	| id cart |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	cart := restInterface findCart: id .	self assert: (cart amount: 1) equals: 2 .	self assert: (cart amount: 7) equals: 1! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 02:37'!test10CanCheckoutWithValidCartAndCreditCart	| id creditCard currentDate debitAmount transaction |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := restInterface checkout: id withCard: creditCard currentDate: currentDate .	self assert: transaction cart equals: (restInterface findCart: id) .	self assert: transaction card equals: creditCard.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:03'!test05CanCreateCartAndGetId	| id cart |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	cart := restInterface findCart: id .	self assert: (cart list isEmpty) .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 01:01'!test02ValidUserInvalidPassDontValidate	self assert: (restInterface validateFor: 'ValidUser' withPass: '123456' ) not .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'JulianBayardo 11/5/2017 16:56'!test13CanReferenceUsersPurchaseHistoryForInvalidPass	| id currentDate creditCard debitAmount transaction transactionList id2 id3 transaction2 |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id2 := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	id3 := restInterface createCartFor: 'AnotherValidUser' withPass: 'AnotherValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	restInterface addToCart: id2 bookIsbn: 7  quantity: 3 .	restInterface addToCart: id3 bookIsbn: 1  quantity: 4 . 	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate next: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | debitAmount := anAmount ].	transaction := restInterface checkout: id withCard: creditCard currentDate: currentDate .	transaction2 := restInterface checkout: id3 withCard: creditCard currentDate: currentDate .	self should: [transactionList := restInterface listPurchasesFor: 'ValidUser' withPass: 'InvalidPass' .] raise: UserInvalidException .! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 14:17'!test14CantAddToExpiredCart	| id |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface setTimerSimulator: [ :anUser | ^false] . "This means that timeout has ocurred"	self should: [restInterface addToCart: id bookIsbn: 1 quantity: 2 .] raise: CartTimeOutException.! !!RESTInterfaceTests methodsFor: 'tests' stamp: 'DamianFurman 11/5/2017 10:35'!test11CantCheckoutWithInvalidCreditCart	| id creditCard currentDate transaction |	id := restInterface createCartFor: 'ValidUser' withPass: 'ValidPass'.	restInterface addToCart: id bookIsbn: 1 quantity: 2 .	restInterface addToCart: id bookIsbn: 7 quantity: 1 .	currentDate := (January first, 2018) .	creditCard := CreditCard owner: 'ValidUser' number: 1234567890123456 expiration: (currentDate previous: (TimeUnits month with: 1)) monthOfYear.	mp debitBehavior: [ :anAmount :aCreditCard | self fail ].	self should: [transaction := restInterface checkout: id withCard: creditCard currentDate: currentDate .] raise: CreditCardExpiredException .! !!RESTInterfaceTests methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 11:54'!setUp	| init book1 book7 |	init := Dictionary new .	init at: 'ValidUser' put: 'ValidPass' .	init at: 'AnotherValidUser' put: 'AnotherValidPass' .	catalog := PriceTable new.	book1 := 1 .	catalog add: book1 price: 10 stock: 7 .	book7 := 7 .	catalog add: book7 price: 8 stock: 9.	mp := MerchantProcessorSimulator new .	restInterface := RESTInterface initializeWithUsers: init catalog: catalog andMP: mp.! !Object subclass: #Timer	instanceVariableNames: 'users carts'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Timer methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 13:40'!initialize	carts := Dictionary new.! !!Timer methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 13:57'!checkTimeoutFor: aCartId	| now |	now := Time now .	^((now hours) * 60 + now minutes < (((carts at: aCartId) hours) * 60 + (carts at: aCartId) minutes + 30)) .! !!Timer methodsFor: 'as yet unclassified' stamp: 'DamianFurman 11/5/2017 13:40'!tickFor: aCartId	carts at: aCartId put: Time now . ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Timer class	instanceVariableNames: ''!!Timer class methodsFor: 'initialization' stamp: 'DamianFurman 11/5/2017 13:33'!initialize	^self new initialize .! !Timer subclass: #TimerSimulator	instanceVariableNames: 'timeoutBehaviour'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!TimerSimulator methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 13:25'!timeoutBehaviour: aBlock	timeoutBehaviour := aBlock .! !!TimerSimulator methodsFor: 'accessing' stamp: 'DamianFurman 11/5/2017 13:27'!checkTimeoutFor: aUser	^timeoutBehaviour value: aUser .! !Object subclass: #Transaction	instanceVariableNames: 'cart price card timestamp'	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!!Transaction methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 19:28'!cart	^ cart! !!Transaction methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 19:28'!card	^ card! !!Transaction methodsFor: 'as yet unclassified' stamp: 'LosPibes 10/30/2017 19:28'!price	^ price! !!Transaction methodsFor: 'initialization' stamp: 'JulianBayardo 10/31/2017 15:42'!initializeCart: aCart price: aPrice card: aCard	cart := aCart.	price := aPrice.	card := aCard! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Transaction class	instanceVariableNames: ''!!Transaction class methodsFor: 'initialization' stamp: 'JulianBayardo 10/31/2017 16:09'!cart: aCart price: aPrice card: aCard	^ super new		initializeCart: aCart		price: aPrice		card: aCard! !Exception subclass: #UserInvalidException	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'TusLibros-Ejercicio'!Timer initialize!